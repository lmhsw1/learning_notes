# redis未授权访问漏洞

## redis持久化机制

![image-20240902231355423](redis未授权访问漏洞/image-20240902231355423.png)	

redis持久化数据，默认使用RDB，说明一下RDB保存方式，其中redis.conf配置文件中，save 3600 1指3600秒内，若有修改1次key，则会触发保存操作。 dbfilename是指明要保存这些内存数据的文件名，dir指明保存文件的路径。

![image-20240902231822453](redis未授权访问漏洞/image-20240902231822453.png)	

## redis的常见用途

![image-20240902232709295](redis未授权访问漏洞/image-20240902232709295.png)	

redis的value可以存放很多数据类型。

![image-20240902232937815](redis未授权访问漏洞/image-20240902232937815.png)	

![image-20240902234335738](redis未授权访问漏洞/image-20240902234335738.png)	

因为redis存放在内存，读写速度会快于mysql等数据库。

![image-20240902234352940](redis未授权访问漏洞/image-20240902234352940.png)	

## redis环境安装

首先在靶场机安装redis的压缩包。

![image-20240903141029862](redis未授权访问漏洞/image-20240903141029862.png)	

解压redis压缩包。

![image-20240903141130814](redis未授权访问漏洞/image-20240903141130814.png)	

由于redis启动需要使用c语言编译，所以需要下载gcc.

![image-20240903141218828](redis未授权访问漏洞/image-20240903141218828.png)	

查看gcc版本发现小于4.9，那么编译该版本的redis会出问题，于是需要升级gcc。

![image-20240903141558520](redis未授权访问漏洞/image-20240903141558520.png)	

升级gcc版本，当安装这个scl库，scl库包含了多个版本的开发工具，安装完后在yum源文件夹会多出两个repo文件。

![image-20240903141629763](redis未授权访问漏洞/image-20240903141629763.png)	

但是Centos7，在2024年6月底就已经停止维护了，所以scl相关的仓库也无法直接使用。

![image-20240903154020537](redis未授权访问漏洞/image-20240903154020537.png)		

所以要修改内容。

![image-20240903154308328](redis未授权访问漏洞/image-20240903154308328.png)	

![image-20240903154251999](redis未授权访问漏洞/image-20240903154251999.png)	

只有修改这两部分内容才能使用yum源。否则yum源无法使用。

![image-20240903154326187](redis未授权访问漏洞/image-20240903154326187.png)	

![image-20240903154336583](redis未授权访问漏洞/image-20240903154336583.png)	

安装为gcc9版本以及相关组件。

![image-20240903154500226](redis未授权访问漏洞/image-20240903154500226.png)	

由于是在scl库下载，所以要enable让其在这个bash生效gcc9,并且source保证以后重启也永久生效。

![image-20240903154746004](redis未授权访问漏洞/image-20240903154746004.png)		

此时gcc升级为版本9.

![image-20240903154805379](redis未授权访问漏洞/image-20240903154805379.png)

使用 `make` 工具编译和安装软件

![image-20240903160624128](redis未授权访问漏洞/image-20240903160624128.png)	

安装成功的结果是src目录下面出现服务端和客户端的脚本

紧接着修改配置文件

![image-20240903160945307](redis未授权访问漏洞/image-20240903160945307.png)	

改为yes,这样redis启动会以后台启动，如果前台启动窗口关闭，redis也会关闭。

![image-20240903161013185](redis未授权访问漏洞/image-20240903161013185.png)	

注释掉这一行，否则redis只能在本机上访问。

![image-20240903161106977](redis未授权访问漏洞/image-20240903161106977.png)	

保护模式设置为no，否则漏洞无法复现。

![image-20240903161519670](redis未授权访问漏洞/image-20240903161519670.png)	

由于该机子作为服务端，还需要配置别名以方便启动redis服务器。

![image-20240903161719844](redis未授权访问漏洞/image-20240903161719844.png)	

添加别名，以后使用redis即可启动redis服务器，也可也使用rcli使用redis服务器。

![image-20240903162741418](redis未授权访问漏洞/image-20240903162741418.png)	

有监听6379端口，说明redis已经启动了。		

![image-20240903162240006](redis未授权访问漏洞/image-20240903162240006.png)

为了保证漏洞复现，可以关闭防火墙，这样客户端(攻击机)才可以访问redis服务器。

![image-20240903162333120](redis未授权访问漏洞/image-20240903162333120.png)	

通过rcli命令进入redis，了解redis的基本操作，flushall是清除redis全部数据。 hset是设置键中的值为一个哈希表。

![image-20240903163114461](redis未授权访问漏洞/image-20240903163114461.png)	

hget专门用于访问哈希表。keys*用于查看所有的键。

![image-20240903163206021](redis未授权访问漏洞/image-20240903163206021.png)	

启动redis服务器的靶场机的ip是192.168.15.50

接下来给攻击机也部署redis，ip是192.168.15.100

还是按照之前的流程安装gcc，并且升级到合适的版本，并且make编译提供的redis文件，来安装redis

最后用redis-cli命令测试，可以连接redis靶场。

![image-20240903165205128](redis未授权访问漏洞/image-20240903165205128.png)	

## redis动态修改配置

![image-20240903170435892](redis未授权访问漏洞/image-20240903170435892.png)	

比如在攻击机中，对redis服务器进行动态配置修改。这两个操作，把redis的持久化数据存放路径改成/root,并且设置保存的文件名为redis.php

![image-20240903170355008](redis未授权访问漏洞/image-20240903170355008.png)	

设置一个值，并手动保存。

![image-20240903170524022](redis未授权访问漏洞/image-20240903170524022.png)	

那么在服务端就能够发现这个redis.php文件。

![image-20240903170545815](redis未授权访问漏洞/image-20240903170545815.png)	

## 提权实战

![image-20240903172009437](redis未授权访问漏洞/image-20240903172009437.png)	

### webshell提权

这里模拟redis服务器同时也部署了http服务器。	

redis服务器安装一个apache

![image-20240903175149722](redis未授权访问漏洞/image-20240903175149722.png)		

![image-20240903175441199](redis未授权访问漏洞/image-20240903175441199.png)	

由于网站根目录在/var/www/html下。攻击机把redis的内存数据以redis.php文件命名，并存放到/var/www/html目录下。并且清空redis所有内容，并且加上一句话木马，并保存。

![image-20240903175820011](redis未授权访问漏洞/image-20240903175820011.png)

但是由于apache服务器没有php环境，所以不能解析这个一句话木马文件，所以先安装remi库。	

![image-20240903192709069](redis未授权访问漏洞/image-20240903192709069.png)

remi库携带了php的包，下载php

![image-20240903192837469](redis未授权访问漏洞/image-20240903192837469.png)	

安装完后配置php.ini配置文件。

![image-20240903193025911](redis未授权访问漏洞/image-20240903193025911.png)	

重启php服务，并使得开机自启。

![image-20240903193224239](redis未授权访问漏洞/image-20240903193224239.png)	

![image-20240903193257959](redis未授权访问漏洞/image-20240903193257959.png)	

并且apache配置文件，需要填写支持解析php文件。但由于我这里apache还是无法解析出php后端代码，所以无法用中国蚁剑连接redis.php。

![image-20240903194249882](redis未授权访问漏洞/image-20240903194249882.png)	

### 反弹连接

![image-20240903230058577](redis未授权访问漏洞/image-20240903230058577.png)	

没有公网IP，但有私有IP可以使用反弹连接。

![image-20240903230203509](redis未授权访问漏洞/image-20240903230203509.png)	

![image-20240903230322259](redis未授权访问漏洞/image-20240903230322259.png)	

常见监听端口有很多方式。

![image-20240904141117558](redis未授权访问漏洞/image-20240904141117558.png)	

接下来演示一下反弹连接操作。

由于centos7没有nc命令需要安装，攻击机安装nc命令，并且监听端口。

![image-20240904141521412](redis未授权访问漏洞/image-20240904141521412.png)	

![image-20240904141553329](redis未授权访问漏洞/image-20240904141553329.png)	

redis服务端反弹连接到到攻击机192.168.15.100

![image-20240904141725945](redis未授权访问漏洞/image-20240904141725945.png)	

此时攻击机连接上了，并且查看ip确实是redis服务器的。

![image-20240904141814774](redis未授权访问漏洞/image-20240904141814774.png)	

第二个监听端口与msf的操作相关，后续课程将会学习，在此忽略。

第三个是使用kali进行7777端口监听

![image-20240904142153146](redis未授权访问漏洞/image-20240904142153146.png)	

redis服务端进行反弹连接。

![image-20240904142226110](redis未授权访问漏洞/image-20240904142226110.png)	

通过ip确实可以发现kali控制了服务端的bash。

![image-20240904142253193](redis未授权访问漏洞/image-20240904142253193.png)	

常见的反弹连接有很多。

![image-20240904142409634](redis未授权访问漏洞/image-20240904142409634.png)	

服务端也安装nc。接下来使用nc的命令进行反弹连接。

![image-20240904142513121](redis未授权访问漏洞/image-20240904142513121.png)	

![image-20240904142912242](redis未授权访问漏洞/image-20240904142912242.png)	

攻击机监听收到，可以实现控制

![image-20240904142844700](redis未授权访问漏洞/image-20240904142844700.png)	

使用python一样可以进行反弹连接。

![image-20240904143157641](redis未授权访问漏洞/image-20240904143157641.png)

![image-20240904143146391](redis未授权访问漏洞/image-20240904143146391.png)	

而常见的反弹连接形式还很多。

![image-20240904143311072](redis未授权访问漏洞/image-20240904143311072.png)	

![image-20240904143329983](redis未授权访问漏洞/image-20240904143329983.png)	

接下来演示使用msf，让微软反弹连接到kali.

使用kali生成一个微软的反弹连接。反弹连接到kali主机的7777端口

![image-20240904143557049](redis未授权访问漏洞/image-20240904143557049.png)	

kali开始使用msf相关的payload监听7777端口

![image-20240904143804535](redis未授权访问漏洞/image-20240904143804535.png)	

分别使用handler监听模块，并选择windows的反弹连接payload，设置监听的主机和端口，并且用exploit开始监听

![image-20240904144006766](redis未授权访问漏洞/image-20240904144006766.png)	

windows下点击这个exe文件。

![image-20240904144105968](redis未授权访问漏洞/image-20240904144105968.png)	

此时反弹连接成功，能查看到被攻击机的操作系统信息。

![image-20240904144133947](redis未授权访问漏洞/image-20240904144133947.png)	

还可以截图获取当前win10的界面。

![image-20240904144219336](redis未授权访问漏洞/image-20240904144219336.png)	

发现确实是截取到了。

![image-20240904144305772](redis未授权访问漏洞/image-20240904144305772.png)	

还可以用shell来切换，此时可以对win10下达命令

![image-20240904144405850](redis未授权访问漏洞/image-20240904144405850.png)	

接下来解释linux的反弹连接命令

![image-20240904144851203](redis未授权访问漏洞/image-20240904144851203.png)	

![image-20240904144927335](redis未授权访问漏洞/image-20240904144927335.png)	

接下来会演示使用redis和定时任务进行反弹连接。

![image-20240904144939146](redis未授权访问漏洞/image-20240904144939146.png)	

### redis写入反弹连接定时任务

linux的定时任务crontab命令。

![image-20240904150109614](redis未授权访问漏洞/image-20240904150109614.png)	

一般跟用户相关的定时文件是存放在/var/spool/cron路径下，并且在/etc目录下，也有放周期相关的任务。

![image-20240904151023044](redis未授权访问漏洞/image-20240904151023044.png)	

比如说，目前只存放了root用户的定时任务文件。

![image-20240904153822811](redis未授权访问漏洞/image-20240904153822811.png)	

在etc目录下也能查找cron周期的配置文件。

![image-20240904153910183](redis未授权访问漏洞/image-20240904153910183.png)	

查看root用户的定时任务列表。

![image-20240904154115211](redis未授权访问漏洞/image-20240904154115211.png)	

删除root用户下的全部定时任务。

![image-20240904154244595](redis未授权访问漏洞/image-20240904154244595.png)	

攻击机监听7777端口。

![image-20240904155456715](redis未授权访问漏洞/image-20240904155456715.png)	

redis客户端故意写入定时任务，意思是每隔一分钟就会反弹连接到攻击机，并且把redis的持久化数据保存到crontab中root用户的默认定时文件下。

添加键值对的时候，其中值的\n是为了换行，来保证不与里面的内容进行拼接导致命令执行不成功。

![image-20240904155700700](redis未授权访问漏洞/image-20240904155700700.png)	

于是建立反弹连接成功。

![image-20240904160017730](redis未授权访问漏洞/image-20240904160017730.png)	

查看到redis服务器的相关文件，从而可以控制靶场机。

![image-20240904160056715](redis未授权访问漏洞/image-20240904160056715.png)	

### SSH Key免密登录

![image-20240904161052198](redis未授权访问漏洞/image-20240904161052198.png)	

![image-20240904161102165](redis未授权访问漏洞/image-20240904161102165.png)	

首先攻击机先删掉默认的ssh密钥，然后新生成私钥和公钥。

![image-20240904172323318](redis未授权访问漏洞/image-20240904172323318.png)	

其中id_rsa.pub就是公钥。

![image-20240904172357100](redis未授权访问漏洞/image-20240904172357100.png)	

查看公钥内容。

![image-20240904172450004](redis未授权访问漏洞/image-20240904172450004.png)	

攻击机在.ssh隐藏目录下的authorized_keys复制这段公钥进去。

![image-20240904172625380](redis未授权访问漏洞/image-20240904172625380.png)	

![image-20240904172713628](redis未授权访问漏洞/image-20240904172713628.png)	

于是攻击机就可以实现ssh免密登陆了。

![image-20240904172811065](redis未授权访问漏洞/image-20240904172811065.png)	

使用redis连接，并且通过键值对的形式把攻击机的公钥加入到redis的数据库中，并且把持久化数据放入到原本ssh公钥所存放的位置。

![image-20240904173318560](redis未授权访问漏洞/image-20240904173318560.png)	

于是实现免密登录。所以哪怕后续redis设置密码了，但是只要之前没设置密码，我们就可以把这个公钥传入到redis服务器来实现免密登录。

![image-20240904173543395](redis未授权访问漏洞/image-20240904173543395.png)

服务端查看这个公钥，虽然实际上看似还有别的数据参杂其中，但只要公钥在里面，就能够触发免密登录。

![image-20240904173734539](redis未授权访问漏洞/image-20240904173734539.png)	

除了以上几种攻击手法，redis还有其他的利用方式。

![image-20240904183727487](redis未授权访问漏洞/image-20240904183727487.png)	

## redis加固方案

![image-20240904183831609](redis未授权访问漏洞/image-20240904183831609.png)	









